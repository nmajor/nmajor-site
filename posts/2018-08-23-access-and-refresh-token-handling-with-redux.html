<!DOCTYPE html><html lang="en" class="h-full antialiased"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" imageSrcSet="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=16&amp;q=75 16w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=32&amp;q=75 32w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=48&amp;q=75 48w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=64&amp;q=75 64w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=96&amp;q=75 96w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=128&amp;q=75 128w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=256&amp;q=75 256w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=384&amp;q=75 384w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=640&amp;q=75 640w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=750&amp;q=75 750w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=828&amp;q=75 828w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=1080&amp;q=75 1080w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=1200&amp;q=75 1200w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=1920&amp;q=75 1920w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=2048&amp;q=75 2048w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=3840&amp;q=75 3840w" imageSizes="2.25rem" fetchPriority="high"/><link rel="stylesheet" href="/_next/static/css/9d8f288a99c54fb3.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-113544170b8b14d7.js" crossorigin=""/><script src="/_next/static/chunks/de8a8aed-ff24f23ca546a20c.js" async="" crossorigin=""></script><script src="/_next/static/chunks/362-edde6a9467fb7f3f.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-dca2b37e6b098eb8.js" async="" crossorigin=""></script><script src="/_next/static/chunks/736-93d26bf9f492bada.js" async=""></script><script src="/_next/static/chunks/545-972397648c423446.js" async=""></script><script src="/_next/static/chunks/871-e93f475163439fcd.js" async=""></script><script src="/_next/static/chunks/app/layout-58152a9375fe786b.js" async=""></script><script src="/_next/static/chunks/app/posts/page-6d06c0c42f2ef9eb.js" async=""></script><title>Access Token Handling (Automatic Refresh) with React + Redux - Spencer Sharp</title><meta name="description" content="I’m Spencer, a software designer and entrepreneur based in New York City. I’m the founder and CEO of Planetaria, where we develop technologies that empower regular people to explore space on their own terms."/><link rel="alternate" type="application/rss+xml" href="undefined/feed.xml"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body class="flex h-full"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="flex w-full"><div class="relative flex w-full flex-col"><header class="pointer-events-none relative z-50 flex flex-none flex-col" style="height:var(--header-height);margin-bottom:var(--header-mb)"><div class="top-0 z-10 h-16 pt-6" style="position:var(--header-position)"><div class="sm:px-8 top-[var(--header-top,theme(spacing.6))] w-full" style="position:var(--header-inner-position)"><div class="mx-auto w-full max-w-7xl lg:px-8"><div class="relative px-4 sm:px-8 lg:px-12"><div class="mx-auto max-w-2xl lg:max-w-5xl"><div class="relative flex gap-4"><div class="flex flex-1"><div class="h-10 w-10 rounded-full bg-white/90 p-0.5 shadow-lg shadow-zinc-800/5 ring-1 ring-zinc-900/5 backdrop-blur dark:bg-zinc-800/90 dark:ring-white/10"><a aria-label="Home" class="pointer-events-auto" href="/"><img alt="" fetchPriority="high" width="1000" height="1000" decoding="async" data-nimg="1" class="rounded-full bg-zinc-100 object-cover dark:bg-zinc-800 h-9 w-9" style="color:transparent" sizes="2.25rem" srcSet="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=16&amp;q=75 16w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=32&amp;q=75 32w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=48&amp;q=75 48w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=64&amp;q=75 64w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=96&amp;q=75 96w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=128&amp;q=75 128w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=256&amp;q=75 256w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=384&amp;q=75 384w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=640&amp;q=75 640w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=750&amp;q=75 750w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=828&amp;q=75 828w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=1080&amp;q=75 1080w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=1200&amp;q=75 1200w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=1920&amp;q=75 1920w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=2048&amp;q=75 2048w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=3840&amp;q=75 3840w" src="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=3840&amp;q=75"/></a></div></div><div class="flex flex-1 justify-end md:justify-center"><nav class="pointer-events-auto hidden md:block"><ul class="flex rounded-full bg-white/90 px-3 text-sm font-medium text-zinc-800 shadow-lg shadow-zinc-800/5 ring-1 ring-zinc-900/5 backdrop-blur dark:bg-zinc-800/90 dark:text-zinc-200 dark:ring-white/10"><li><a class="relative block px-3 py-2 transition hover:text-teal-500 dark:hover:text-teal-400" href="/about">About</a></li><li><a class="relative block px-3 py-2 transition hover:text-teal-500 dark:hover:text-teal-400" href="/posts">Blog</a></li><li><a class="relative block px-3 py-2 transition hover:text-teal-500 dark:hover:text-teal-400" href="/projects">Projects</a></li></ul></nav></div><div class="flex justify-end md:flex-1"><div class="pointer-events-auto"><button class="inline-flex items-center justify-center text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 hover:bg-accent hover:text-accent-foreground rounded-md h-8 w-8 px-0" type="button" id="radix-:R75la:" aria-haspopup="menu" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0"><circle cx="12" cy="12" r="4"></circle><path d="M12 3v1"></path><path d="M12 20v1"></path><path d="M3 12h1"></path><path d="M20 12h1"></path><path d="m18.364 5.636-.707.707"></path><path d="m6.343 17.657-.707.707"></path><path d="m5.636 5.636.707.707"></path><path d="m17.657 17.657.707.707"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="absolute rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg><span class="sr-only">Toggle theme</span></button></div></div></div></div></div></div></div></div></header><main class="flex-auto"><div class="sm:px-8 post mt-16 lg:mt-32"><div class="mx-auto w-full max-w-7xl lg:px-8"><div class="relative px-4 sm:px-8 lg:px-12"><div class="mx-auto max-w-2xl lg:max-w-5xl"><div class="xl:relative"><div class="mx-auto max-w-2xl"><article><header class="flex flex-col"><h1 class="text-4xl font-bold font-bold tracking-tight sm:text-5xl">Access Token Handling (Automatic Refresh) with React + Redux</h1><div class="flex gap-3 pt-1"><time dateTime="2018-08-23" class="text-muted-foreground order-first flex items-center pr-2 text-base"><span class="h-4 w-0.5 rounded-full bg-zinc-200 dark:bg-zinc-500"></span><span class="ml-3">August 23, 2018</span></time><span class="text-muted-foreground">-</span><span class="text-muted-foreground/80">react</span><span class="text-muted-foreground/80">redux</span><span class="text-muted-foreground/80">authentication</span></div><div class="text-accent-foreground pt-3 text-sm italic">~<!-- -->8 min read</div></header><div class="mt-8 prose dark:prose-invert" data-mdx-content="true"><div><p>Here is the approach I've used recently and it seems to work out pretty well. Its very similar to the approach I found <a href="https://michaelwashburnjr.com/best-way-to-store-tokens-redux/" title="https://michaelwashburnjr.com/best-way-to-store-tokens-redux/">here</a>. In this example I'm dealing with accessToken + refreshToken, but this could easily be adapted to different kinds of tokens (a JWT auth for example).</p>
<h3 id="break-it-down"><a aria-hidden="true" tabindex="-1" href="#break-it-down"><a href="#break-it-down" style="margin-right: 10px">#</a></a>Break it down</h3>
<p>First we'll make sure that redux has gets the token. In my case this means passing it from the server after the authentication callback.</p>
<p>Then we will use a simple redux subscriber to store our auth tokens in the browser localStorage. Using a subscriber will keep it synced so that anytime the auth token in the redux state changes it updates it in the localStorage.</p>
<p>Then we'll make sure that anytime we refresh the page, we load in the auth tokens from localStorage when creating the store.</p>
<p>Then we'll add some middleware that happens before each outgoing HTTP request that will refresh the token if needed, and update the redux state with the new tokens, and our subscriber will automatically update the token in localStorage.</p>
<h3 id="get-the-token-from-the-server-to-redux"><a aria-hidden="true" tabindex="-1" href="#get-the-token-from-the-server-to-redux"><a href="#get-the-token-from-the-server-to-redux" style="margin-right: 10px">#</a></a>Get the Token from the Server to Redux</h3>
<p>You can probably skip this part if you are already getting your auth tokens to redux some other way.</p>
<p>In my case, I'm authenticating with Microsofts Oauth2 service. and the tokens are being sent to the server via a RedirectURI callback, that means I need to pass the tokens from the server to the client. I don't store it in the session or database, Instead I pass it back to the client using the <code>window.__PRELOADED_STATE__</code> demonstrated in the <a href="https://redux.js.org/recipes/serverrendering">Redux server rendering documentation</a>.</p>
<p>I've decided to store my auth tokens in redux under <code>state.auth.tokens</code>, so my preloadedState object will look like this:</p>
<pre><code>const preloadedState = {
  auth: {
    tokens: { /* Auth token data goes here */ }
  }
}
</code></pre>
<p>Then we set that as the value of the <code>window.__PRELOADED_STATE__</code>, in the server rendered html like this (Making sure to include these lines BEFORE loading in the client js bundle):</p>
<pre><code>&#x3C;script>
  window.__PRELOADED_STATE__ = ${JSON.stringify(preloadedState).replace(/&#x3C;/g, '\\u003c')}
  
  /* The string replace is to prevent injections into our preloaded state. Check the redux server rendering docs for more info */
&#x3C;/script>
</code></pre>
<p>Then when loading the store, load in the <code>window.__PRELOADED_STATE__</code> as the initial state when creating the redux store:</p>
<pre><code>const store = createStore(reducer, window.__PRELOADED_STATE__)
</code></pre>
<h3 id="sync-auth-state-to-localstorage"><a aria-hidden="true" tabindex="-1" href="#sync-auth-state-to-localstorage"><a href="#sync-auth-state-to-localstorage" style="margin-right: 10px">#</a></a>Sync Auth State to localStorage</h3>
<p>Thanks again to <a href="https://michaelwashburnjr.com/best-way-to-store-tokens-redux/">this post</a> for the idea of using a simple redux store subscriber to keep localStorage synced with out auth section of the redux store.</p>
<p>I made a function that will serialize and set the localStorage variables, and then call that function from <code>store.subscribe</code></p>
<pre><code>function setAuthState(state) {
  try {
    localStorage.setItem('state.auth.tokens', JSON.stringify((state.auth || {}).tokens));
  } catch (err) { return undefined; }
}

store.subscribe(() => {
  setAuthState(store.getState())
});
</code></pre>
<p>Be sure to checkout the <a href="https://redux.js.org/api/store#subscribe">documentation for store.subscribe</a>. You can also checkout <a href="https://egghead.io/lessons/javascript-redux-persisting-the-state-to-the-local-storage">this video</a> by Dan Abramov on how to use subscribe to store the state into localStorage.</p>
<p>Some other libraries for watching the state for mutations are <a href="https://github.com/jprichardson/redux-watch">redux-watch</a> and <a href="https://github.com/ashaffer/redux-subscribe">redux-subscribe</a>. They may be a better option later, but for now I'm going with this simple subscribe approach.</p>
<h3 id="load-auth-from-localstorage-on-refresh"><a aria-hidden="true" tabindex="-1" href="#load-auth-from-localstorage-on-refresh"><a href="#load-auth-from-localstorage-on-refresh" style="margin-right: 10px">#</a></a>Load Auth From localStorage on Refresh</h3>
<p>Then I made a function to get and deserialize the state from localStorage:</p>
<pre><code>function getAuthState() {
  try {
    const tokens = JSON.parse(localStorage.getItem('state.auth.tokens')) || undefined;
    const user = JSON.parse(localStorage.getItem('state.auth.user')) || undefined;

    return { auth: { tokens, user } }
  } catch (err) { return undefined; }
}
</code></pre>
<p>Then change our create store to something like this:</p>
<pre><code>const store = createStore(
  reducer,
  { ...getAuthState(), ...window.__PRELOADED_STATE__ }
 )
</code></pre>
<p>And I was able to refresh the page and the auth tokens persist. So it works!</p>
<h3 id="automatic-token-refreshing"><a aria-hidden="true" tabindex="-1" href="#automatic-token-refreshing"><a href="#automatic-token-refreshing" style="margin-right: 10px">#</a></a>Automatic Token Refreshing</h3>
<p>I debated whether or not to include this part, because there's so many different ways to implement it, but the ways I think are truly nice and elegant can be a bit complex for a blog post. But I'll try anyway. Hopefully people can get a few good ideas from this.</p>
<p>Now this step is going to vary a lot depending on your implementation. I was greatly inspired by <a href="https://github.com/erikras/react-redux-universal-hot-example">this library (erikras/react-redux-universal-hot-example)</a> which has a really nice middleware setup for making API requests by dispatching redux actions.</p>
<p>Although my final implementation looks much more like that the middleware found in the <a href="https://github.com/erikras/react-redux-universal-hot-example">erikras/react-redux-universal-hot-example</a> mentioned above, here is an exmample of how you might do a simplified version of some API request middleware with the refresh token.</p>
<p>I'm assuming you are using a function dispatcher middleware like <a href="https://github.com/reduxjs/redux-thunk">redux-thunk</a> and <a href="https://github.com/visionmedia/superagent">superagent</a> as the request library.</p>
<p>You'll also notice that I loaded my tokens with an <code>expires_at</code> attribute to help calculate when a refresh is needed.</p>
<p>The middleware is in a file called <code>requestMiddleware.js</code> and looks something like this like this:</p>
<pre><code>export default function requestMiddleware() {
  return ({ dispatch, getState }) => next => (action) => {
    const {
      request,
    } = action;

    if (!request) {
      return next(action);
    }

    const { tokens } = getState().auth;

    // 5 minutes from now
    const refreshThreshold = (new Date.getTime() + 300000);

    if (tokens.refresh_token &#x26;&#x26; refreshThreshold > tokens.expires_at) {
      return superagent.post('/path/to/renew')
        .send({ refresh_token: tokens.refresh_token })
        .end((err, { body } = {}) => {
          dispatch({ type: 'SET_TOKENS', payload: body });
          request(body);
        });
    }
    return request(tokens);
  };
}
</code></pre>
<p>Dont forget to apply the middleware:</p>
<pre><code>import { createStore, applyMiddleware } from 'redux';
import requestMiddleware from './middleware/requestMiddleware';
import rootReducer from './reducers/index';

const store = createStore(
  rootReducer,
  applyMiddleware(requestMiddleware())
);
</code></pre>
<p>Add a reducer to capture the <code>SET_TOKEN</code> action:</p>
<pre><code>export default function reducer(state = initialState, action = {}) {
  switch (action.type) {
    case SET_TOKENS:
      return {
        ...state,
        auth: { tokens: action.payload },
      };
    default:
      return state;
  }
}
</code></pre>
<p>And now we can dispatch actions like this:</p>
<pre><code>export default function sendAnyRequest() {
  return (dispatch) => {
    return {
      request: (tokens) => superagent.post('/some/random/request')
        .send({ foo: 'bar' })
        .end((err, { body } = {}) => {
          dispatch({ type: 'SOME_EVENT', payload: body });
        });
    }
  }
}
</code></pre>
<h3 id="wrap-it-up"><a aria-hidden="true" tabindex="-1" href="#wrap-it-up"><a href="#wrap-it-up" style="margin-right: 10px">#</a></a>Wrap it up</h3>
<p>And before making any request it will first check the validity of the refresh token and refresh it if needed. And if a refresh does occur it will set the new token in the redux store, which will be automatically written to the localStorage by the subscriber.</p>
<p>Noice!</p>
<p>I highly recommend you read through the code of this project <a href="https://github.com/erikras/react-redux-universal-hot-example">erikras/react-redux-universal-hot-example</a>, specifically the <code>ApiClient.js</code>, <code>clientMiddleware.js</code>, and see how the request actions are dispatched.</p>
<p>As I said, I used that example heavily when setting up my redux store. Here is what my middleware file looks like:</p>
<pre><code>import { SIGN_OUT, SET_TOKENS } from '../modules/auth';

export default function clientMiddleware(client) {
  return ({ dispatch, getState }) => next => (action) => {
    if (typeof action === 'function') {
      return action(dispatch, getState);
    }

    const {
      promise, types, ...rest
    } = action;
    if (!promise) {
      return next(action);
    }

    // eslint-disable-next-line no-param-reassign
    client.token = (getState().auth.tokens || {}).access_token;

    const [REQUEST, SUCCESS, FAILURE] = types;
    next({ ...rest, type: REQUEST });

    let actionPromise = Promise.resolve();
    const { tokens } = getState().auth;

    const refreshThreshold = (new Date().getTime() + 300000); // 5 minutes from now

    if (tokens.refresh_token &#x26;&#x26; refreshThreshold > tokens.expires_at) {
      actionPromise = client.post('/my-server/renew', { data: { refresh_token: tokens.refresh_token } })
        .then(
          (result) => {
            client.token = result.access_token;
            return next({
              ...rest, result, type: SET_TOKENS,
            });
          },
          errors => next({
            ...rest, errors, type: SIGN_OUT,
          }),
        )
        .then(() => promise(client));
    } else {
      actionPromise = promise(client);
    }

    actionPromise.then(
      result => next({ ...rest, result, type: SUCCESS }),
      errors => next({ ...rest, errors, type: FAILURE }),
    ).catch((error) => {
      console.error('MIDDLEWARE ERROR:', error);
      next({ ...rest, error, type: FAILURE });
    });

    return actionPromise;
  };
}
</code></pre>
<p>And I can dispatch really clean actions that look like this:</p>
<pre><code>export function loadOne(_id) {
  return {
    types: [LOAD, LOAD_SUCCESS, LOAD_FAIL],
    promise: client => client.get('/items/'),
  };
}
</code></pre>
<p>And the tokens are automatically refreshed and persisted.</p>
<p>I still have some cleaning up to do with my setup. I'd like to modularize that refresh token bit. I first tried to put it into its own middleware, but the existing client middleware dispatches an initial action (LOAD in the example above) that triggers the loading state and adds spinners. Having the refresh token part in its own middleware delayed the loading state until after the refresh so it made for a bad user experience.</p>
<p>It seems to be pretty functional and reliable so far. I'll be sure to update this article if I discover any problems or brittleness with this implementation.</p>
<p>If you notice any mistakes in here, or if you have any ideas on how to improve this setup, please let me know in the comments. I'm always looking for better patterns to follow.</p></div></div></article></div></div></div></div></div></div></main><footer class="mt-32 flex-none"><div class="sm:px-8"><div class="mx-auto w-full max-w-7xl lg:px-8"><div class="pb-16 pt-10"><div class="relative px-4 sm:px-8 lg:px-12"><div class="mx-auto max-w-2xl lg:max-w-5xl"><div class="flex flex-col items-center justify-between gap-6 sm:flex-row"><div class="flex flex-wrap justify-center gap-x-6 gap-y-1 text-sm font-medium text-zinc-800 dark:text-zinc-200"><a class="transition hover:text-teal-500 dark:hover:text-teal-400" href="/about">About</a><a class="transition hover:text-teal-500 dark:hover:text-teal-400" href="/projects">Projects</a><a class="transition hover:text-teal-500 dark:hover:text-teal-400" href="/speaking">Speaking</a><a class="transition hover:text-teal-500 dark:hover:text-teal-400" href="/uses">Uses</a></div><p class="text-sm text-zinc-400 dark:text-zinc-500">© <!-- -->2023<!-- --> Spencer Sharp. All rights reserved.</p></div></div></div></div></div></div></footer></div></div><script src="/_next/static/chunks/webpack-113544170b8b14d7.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/9d8f288a99c54fb3.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:I[7483,[],\"\"]\n5:I[655,[],\"\"]\n6:I[2286,[\"736\",\"static/chunks/736-93d26bf9f492bada.js\",\"545\",\"static/chunks/545-972397648c423446.js\",\"871\",\"static/chunks/871-e93f475163439fcd.js\",\"185\",\"static/chunks/app/layout-58152a9375fe786b.js\"],\"ThemeProvider\"]\n7:I[7019,[\"736\",\"static/chunks/736-93d26bf9f492bada.js\",\"545\",\"static/chunks/545-972397648c423446.js\",\"871\",\"static/chunks/871-e93f475163439fcd.js\",\"185\",\"static/chunks/app/layout-58152a9375fe786b.js\"],\"Header\"]\n8:I[3849,[],\"\"]\n9:I[8656,[],\"\"]\na:I[4736,[\"736\",\"s"])</script><script>self.__next_f.push([1,"tatic/chunks/736-93d26bf9f492bada.js\",\"991\",\"static/chunks/app/posts/page-6d06c0c42f2ef9eb.js\"],\"\"]\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/9d8f288a99c54fb3.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"AzO8YmqLI-jVS4hv3vlbF\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/posts/2018-08-23-access-and-refresh-token-handling-with-redux\",\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"2018-08-23-access-and-refresh-token-handling-with-redux\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"2018-08-23-access-and-refresh-token-handling-with-redux\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L4\"],\"globalErrorComponent\":\"$5\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"className\":\"h-full antialiased\",\"suppressHydrationWarning\":true,\"children\":[\"$\",\"body\",null,{\"className\":\"flex h-full\",\"children\":[\"$\",\"$L6\",null,{\"attribute\":\"class\",\"defaultTheme\":\"system\",\"enableSystem\":true,\"disableTransitionOnChange\":true,\"children\":[\"$\",\"div\",null,{\"className\":\"flex w-full\",\"children\":[\"$\",\"div\",null,{\"className\":\"relative flex w-full flex-col\",\"children\":[[\"$\",\"$L7\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-auto\",\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"sm:px-8 flex h-full items-center pt-16 sm:pt-32\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto w-full max-w-7xl lg:px-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"relative px-4 sm:px-8 lg:px-12\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-2xl lg:max-w-5xl\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center\",\"children\":[[\"$\",\"p\",null,{\"className\":\"text-base font-semibold text-zinc-400 dark:text-zinc-500\",\"children\":\"404\"}],[\"$\",\"h1\",null,{\"className\":\"mt-4 text-4xl font-bold tracking-tight text-zinc-800 dark:text-zinc-100 sm:text-5xl\",\"children\":\"Page not found\"}],[\"$\",\"p\",null,{\"className\":\"mt-4 text-base text-zinc-600 dark:text-zinc-400\",\"children\":\"Sorry, we couldn’t find the page you’re looking for.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"children\":[\"$\",\"button\",null,{\"className\":\"inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-primary text-primary-foreground hover:bg-primary/90 h-10 px-4 py-2 mt-4\",\"children\":\"Go back home\"}]}]]}]}]}]}]}],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",[\"slug\",\"2018-08-23-access-and-refresh-token-handling-with-redux\",\"d\"],\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$Lb\",\"$Lc\",null],\"segment\":\"__PAGE__?{\\\"slug\\\":\\\"2018-08-23-access-and-refresh-token-handling-with-redux\\\"}\"},\"styles\":null}],\"segment\":[\"slug\",\"2018-08-23-access-and-refresh-token-handling-with-redux\",\"d\"]},\"styles\":null}],\"segment\":\"posts\"},\"styles\":null}]}],[\"$\",\"footer\",null,{\"className\":\"mt-32 flex-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sm:px-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto w-full max-w-7xl lg:px-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"pb-16 pt-10\",\"children\":[\"$\",\"div\",null,{\"className\":\"relative px-4 sm:px-8 lg:px-12\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-2xl lg:max-w-5xl\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-between gap-6 sm:flex-row\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex flex-wrap justify-center gap-x-6 gap-y-1 text-sm font-medium text-zinc-800 dark:text-zinc-200\",\"children\":[[\"$\",\"$La\",null,{\"href\":\"/about\",\"className\":\"transition hover:text-teal-500 dark:hover:text-teal-400\",\"children\":\"About\"}],[\"$\",\"$La\",null,{\"href\":\"/projects\",\"className\":\"transition hover:text-teal-500 dark:hover:text-teal-400\",\"children\":\"Projects\"}],[\"$\",\"$La\",null,{\"href\":\"/speaking\",\"className\":\"transition hover:text-teal-500 dark:hover:text-teal-400\",\"children\":\"Speaking\"}],[\"$\",\"$La\",null,{\"href\":\"/uses\",\"className\":\"transition hover:text-teal-500 dark:hover:text-teal-400\",\"children\":\"Uses\"}]]}],[\"$\",\"p\",null,{\"className\":\"text-sm text-zinc-400 dark:text-zinc-500\",\"children\":[\"© \",2023,\" Spencer Sharp. All rights reserved.\"]}]]}]}]}]}]}]}]}]]}]}]}]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"d:T30e9,"])</script><script>self.__next_f.push([1,"\u003cp\u003eHere is the approach I've used recently and it seems to work out pretty well. Its very similar to the approach I found \u003ca href=\"https://michaelwashburnjr.com/best-way-to-store-tokens-redux/\" title=\"https://michaelwashburnjr.com/best-way-to-store-tokens-redux/\"\u003ehere\u003c/a\u003e. In this example I'm dealing with accessToken + refreshToken, but this could easily be adapted to different kinds of tokens (a JWT auth for example).\u003c/p\u003e\n\u003ch3 id=\"break-it-down\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#break-it-down\"\u003e\u003ca href=\"#break-it-down\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eBreak it down\u003c/h3\u003e\n\u003cp\u003eFirst we'll make sure that redux has gets the token. In my case this means passing it from the server after the authentication callback.\u003c/p\u003e\n\u003cp\u003eThen we will use a simple redux subscriber to store our auth tokens in the browser localStorage. Using a subscriber will keep it synced so that anytime the auth token in the redux state changes it updates it in the localStorage.\u003c/p\u003e\n\u003cp\u003eThen we'll make sure that anytime we refresh the page, we load in the auth tokens from localStorage when creating the store.\u003c/p\u003e\n\u003cp\u003eThen we'll add some middleware that happens before each outgoing HTTP request that will refresh the token if needed, and update the redux state with the new tokens, and our subscriber will automatically update the token in localStorage.\u003c/p\u003e\n\u003ch3 id=\"get-the-token-from-the-server-to-redux\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#get-the-token-from-the-server-to-redux\"\u003e\u003ca href=\"#get-the-token-from-the-server-to-redux\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eGet the Token from the Server to Redux\u003c/h3\u003e\n\u003cp\u003eYou can probably skip this part if you are already getting your auth tokens to redux some other way.\u003c/p\u003e\n\u003cp\u003eIn my case, I'm authenticating with Microsofts Oauth2 service. and the tokens are being sent to the server via a RedirectURI callback, that means I need to pass the tokens from the server to the client. I don't store it in the session or database, Instead I pass it back to the client using the \u003ccode\u003ewindow.__PRELOADED_STATE__\u003c/code\u003e demonstrated in the \u003ca href=\"https://redux.js.org/recipes/serverrendering\"\u003eRedux server rendering documentation\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eI've decided to store my auth tokens in redux under \u003ccode\u003estate.auth.tokens\u003c/code\u003e, so my preloadedState object will look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst preloadedState = {\n  auth: {\n    tokens: { /* Auth token data goes here */ }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen we set that as the value of the \u003ccode\u003ewindow.__PRELOADED_STATE__\u003c/code\u003e, in the server rendered html like this (Making sure to include these lines BEFORE loading in the client js bundle):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#x3C;script\u003e\n  window.__PRELOADED_STATE__ = ${JSON.stringify(preloadedState).replace(/\u0026#x3C;/g, '\\\\u003c')}\n  \n  /* The string replace is to prevent injections into our preloaded state. Check the redux server rendering docs for more info */\n\u0026#x3C;/script\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen when loading the store, load in the \u003ccode\u003ewindow.__PRELOADED_STATE__\u003c/code\u003e as the initial state when creating the redux store:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst store = createStore(reducer, window.__PRELOADED_STATE__)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"sync-auth-state-to-localstorage\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#sync-auth-state-to-localstorage\"\u003e\u003ca href=\"#sync-auth-state-to-localstorage\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eSync Auth State to localStorage\u003c/h3\u003e\n\u003cp\u003eThanks again to \u003ca href=\"https://michaelwashburnjr.com/best-way-to-store-tokens-redux/\"\u003ethis post\u003c/a\u003e for the idea of using a simple redux store subscriber to keep localStorage synced with out auth section of the redux store.\u003c/p\u003e\n\u003cp\u003eI made a function that will serialize and set the localStorage variables, and then call that function from \u003ccode\u003estore.subscribe\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction setAuthState(state) {\n  try {\n    localStorage.setItem('state.auth.tokens', JSON.stringify((state.auth || {}).tokens));\n  } catch (err) { return undefined; }\n}\n\nstore.subscribe(() =\u003e {\n  setAuthState(store.getState())\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBe sure to checkout the \u003ca href=\"https://redux.js.org/api/store#subscribe\"\u003edocumentation for store.subscribe\u003c/a\u003e. You can also checkout \u003ca href=\"https://egghead.io/lessons/javascript-redux-persisting-the-state-to-the-local-storage\"\u003ethis video\u003c/a\u003e by Dan Abramov on how to use subscribe to store the state into localStorage.\u003c/p\u003e\n\u003cp\u003eSome other libraries for watching the state for mutations are \u003ca href=\"https://github.com/jprichardson/redux-watch\"\u003eredux-watch\u003c/a\u003e and \u003ca href=\"https://github.com/ashaffer/redux-subscribe\"\u003eredux-subscribe\u003c/a\u003e. They may be a better option later, but for now I'm going with this simple subscribe approach.\u003c/p\u003e\n\u003ch3 id=\"load-auth-from-localstorage-on-refresh\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#load-auth-from-localstorage-on-refresh\"\u003e\u003ca href=\"#load-auth-from-localstorage-on-refresh\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eLoad Auth From localStorage on Refresh\u003c/h3\u003e\n\u003cp\u003eThen I made a function to get and deserialize the state from localStorage:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction getAuthState() {\n  try {\n    const tokens = JSON.parse(localStorage.getItem('state.auth.tokens')) || undefined;\n    const user = JSON.parse(localStorage.getItem('state.auth.user')) || undefined;\n\n    return { auth: { tokens, user } }\n  } catch (err) { return undefined; }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen change our create store to something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst store = createStore(\n  reducer,\n  { ...getAuthState(), ...window.__PRELOADED_STATE__ }\n )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd I was able to refresh the page and the auth tokens persist. So it works!\u003c/p\u003e\n\u003ch3 id=\"automatic-token-refreshing\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#automatic-token-refreshing\"\u003e\u003ca href=\"#automatic-token-refreshing\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eAutomatic Token Refreshing\u003c/h3\u003e\n\u003cp\u003eI debated whether or not to include this part, because there's so many different ways to implement it, but the ways I think are truly nice and elegant can be a bit complex for a blog post. But I'll try anyway. Hopefully people can get a few good ideas from this.\u003c/p\u003e\n\u003cp\u003eNow this step is going to vary a lot depending on your implementation. I was greatly inspired by \u003ca href=\"https://github.com/erikras/react-redux-universal-hot-example\"\u003ethis library (erikras/react-redux-universal-hot-example)\u003c/a\u003e which has a really nice middleware setup for making API requests by dispatching redux actions.\u003c/p\u003e\n\u003cp\u003eAlthough my final implementation looks much more like that the middleware found in the \u003ca href=\"https://github.com/erikras/react-redux-universal-hot-example\"\u003eerikras/react-redux-universal-hot-example\u003c/a\u003e mentioned above, here is an exmample of how you might do a simplified version of some API request middleware with the refresh token.\u003c/p\u003e\n\u003cp\u003eI'm assuming you are using a function dispatcher middleware like \u003ca href=\"https://github.com/reduxjs/redux-thunk\"\u003eredux-thunk\u003c/a\u003e and \u003ca href=\"https://github.com/visionmedia/superagent\"\u003esuperagent\u003c/a\u003e as the request library.\u003c/p\u003e\n\u003cp\u003eYou'll also notice that I loaded my tokens with an \u003ccode\u003eexpires_at\u003c/code\u003e attribute to help calculate when a refresh is needed.\u003c/p\u003e\n\u003cp\u003eThe middleware is in a file called \u003ccode\u003erequestMiddleware.js\u003c/code\u003e and looks something like this like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport default function requestMiddleware() {\n  return ({ dispatch, getState }) =\u003e next =\u003e (action) =\u003e {\n    const {\n      request,\n    } = action;\n\n    if (!request) {\n      return next(action);\n    }\n\n    const { tokens } = getState().auth;\n\n    // 5 minutes from now\n    const refreshThreshold = (new Date.getTime() + 300000);\n\n    if (tokens.refresh_token \u0026#x26;\u0026#x26; refreshThreshold \u003e tokens.expires_at) {\n      return superagent.post('/path/to/renew')\n        .send({ refresh_token: tokens.refresh_token })\n        .end((err, { body } = {}) =\u003e {\n          dispatch({ type: 'SET_TOKENS', payload: body });\n          request(body);\n        });\n    }\n    return request(tokens);\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDont forget to apply the middleware:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport { createStore, applyMiddleware } from 'redux';\nimport requestMiddleware from './middleware/requestMiddleware';\nimport rootReducer from './reducers/index';\n\nconst store = createStore(\n  rootReducer,\n  applyMiddleware(requestMiddleware())\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAdd a reducer to capture the \u003ccode\u003eSET_TOKEN\u003c/code\u003e action:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport default function reducer(state = initialState, action = {}) {\n  switch (action.type) {\n    case SET_TOKENS:\n      return {\n        ...state,\n        auth: { tokens: action.payload },\n      };\n    default:\n      return state;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd now we can dispatch actions like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport default function sendAnyRequest() {\n  return (dispatch) =\u003e {\n    return {\n      request: (tokens) =\u003e superagent.post('/some/random/request')\n        .send({ foo: 'bar' })\n        .end((err, { body } = {}) =\u003e {\n          dispatch({ type: 'SOME_EVENT', payload: body });\n        });\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"wrap-it-up\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#wrap-it-up\"\u003e\u003ca href=\"#wrap-it-up\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eWrap it up\u003c/h3\u003e\n\u003cp\u003eAnd before making any request it will first check the validity of the refresh token and refresh it if needed. And if a refresh does occur it will set the new token in the redux store, which will be automatically written to the localStorage by the subscriber.\u003c/p\u003e\n\u003cp\u003eNoice!\u003c/p\u003e\n\u003cp\u003eI highly recommend you read through the code of this project \u003ca href=\"https://github.com/erikras/react-redux-universal-hot-example\"\u003eerikras/react-redux-universal-hot-example\u003c/a\u003e, specifically the \u003ccode\u003eApiClient.js\u003c/code\u003e, \u003ccode\u003eclientMiddleware.js\u003c/code\u003e, and see how the request actions are dispatched.\u003c/p\u003e\n\u003cp\u003eAs I said, I used that example heavily when setting up my redux store. Here is what my middleware file looks like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport { SIGN_OUT, SET_TOKENS } from '../modules/auth';\n\nexport default function clientMiddleware(client) {\n  return ({ dispatch, getState }) =\u003e next =\u003e (action) =\u003e {\n    if (typeof action === 'function') {\n      return action(dispatch, getState);\n    }\n\n    const {\n      promise, types, ...rest\n    } = action;\n    if (!promise) {\n      return next(action);\n    }\n\n    // eslint-disable-next-line no-param-reassign\n    client.token = (getState().auth.tokens || {}).access_token;\n\n    const [REQUEST, SUCCESS, FAILURE] = types;\n    next({ ...rest, type: REQUEST });\n\n    let actionPromise = Promise.resolve();\n    const { tokens } = getState().auth;\n\n    const refreshThreshold = (new Date().getTime() + 300000); // 5 minutes from now\n\n    if (tokens.refresh_token \u0026#x26;\u0026#x26; refreshThreshold \u003e tokens.expires_at) {\n      actionPromise = client.post('/my-server/renew', { data: { refresh_token: tokens.refresh_token } })\n        .then(\n          (result) =\u003e {\n            client.token = result.access_token;\n            return next({\n              ...rest, result, type: SET_TOKENS,\n            });\n          },\n          errors =\u003e next({\n            ...rest, errors, type: SIGN_OUT,\n          }),\n        )\n        .then(() =\u003e promise(client));\n    } else {\n      actionPromise = promise(client);\n    }\n\n    actionPromise.then(\n      result =\u003e next({ ...rest, result, type: SUCCESS }),\n      errors =\u003e next({ ...rest, errors, type: FAILURE }),\n    ).catch((error) =\u003e {\n      console.error('MIDDLEWARE ERROR:', error);\n      next({ ...rest, error, type: FAILURE });\n    });\n\n    return actionPromise;\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd I can dispatch really clean actions that look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport function loadOne(_id) {\n  return {\n    types: [LOAD, LOAD_SUCCESS, LOAD_FAIL],\n    promise: client =\u003e client.get('/items/'),\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd the tokens are automatically refreshed and persisted.\u003c/p\u003e\n\u003cp\u003eI still have some cleaning up to do with my setup. I'd like to modularize that refresh token bit. I first tried to put it into its own middleware, but the existing client middleware dispatches an initial action (LOAD in the example above) that triggers the loading state and adds spinners. Having the refresh token part in its own middleware delayed the loading state until after the refresh so it made for a bad user experience.\u003c/p\u003e\n\u003cp\u003eIt seems to be pretty functional and reliable so far. I'll be sure to update this article if I discover any problems or brittleness with this implementation.\u003c/p\u003e\n\u003cp\u003eIf you notice any mistakes in here, or if you have any ideas on how to improve this setup, please let me know in the comments. I'm always looking for better patterns to follow.\u003c/p\u003e"])</script><script>self.__next_f.push([1,"c:[\"$\",\"div\",null,{\"className\":\"sm:px-8 post mt-16 lg:mt-32\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto w-full max-w-7xl lg:px-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"relative px-4 sm:px-8 lg:px-12\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-2xl lg:max-w-5xl\",\"children\":[\"$\",\"div\",null,{\"className\":\"xl:relative\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-2xl\",\"children\":[\"$\",\"article\",null,{\"children\":[[\"$\",\"header\",null,{\"className\":\"flex flex-col\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold font-bold tracking-tight sm:text-5xl\",\"children\":\"Access Token Handling (Automatic Refresh) with React + Redux\"}],[\"$\",\"div\",null,{\"className\":\"flex gap-3 pt-1\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2018-08-23\",\"className\":\"text-muted-foreground order-first flex items-center pr-2 text-base\",\"children\":[[\"$\",\"span\",null,{\"className\":\"h-4 w-0.5 rounded-full bg-zinc-200 dark:bg-zinc-500\"}],[\"$\",\"span\",null,{\"className\":\"ml-3\",\"children\":\"August 23, 2018\"}]]}],[\"$\",\"span\",null,{\"className\":\"text-muted-foreground\",\"children\":\"-\"}],[[\"$\",\"span\",\"react\",{\"className\":\"text-muted-foreground/80\",\"children\":\"react\"}],[\"$\",\"span\",\"redux\",{\"className\":\"text-muted-foreground/80\",\"children\":\"redux\"}],[\"$\",\"span\",\"authentication\",{\"className\":\"text-muted-foreground/80\",\"children\":\"authentication\"}]]]}],[\"$\",\"div\",null,{\"className\":\"text-accent-foreground pt-3 text-sm italic\",\"children\":[\"~\",\"8 min read\"]}]]}],[\"$\",\"div\",null,{\"className\":\"mt-8 prose dark:prose-invert\",\"data-mdx-content\":true,\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}]]}]}]}]}]}]}]}]\n"])</script><script>self.__next_f.push([1,"4:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Access Token Handling (Automatic Refresh) with React + Redux - Spencer Sharp\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"I’m Spencer, a software designer and entrepreneur based in New York City. I’m the founder and CEO of Planetaria, where we develop technologies that empower regular people to explore space on their own terms.\"}],[\"$\",\"link\",\"4\",{\"rel\":\"alternate\",\"type\":\"application/rss+xml\",\"href\":\"undefined/feed.xml\"}]]\n"])</script><script>self.__next_f.push([1,"b:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>