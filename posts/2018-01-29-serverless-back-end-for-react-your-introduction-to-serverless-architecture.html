<!DOCTYPE html><html lang="en" class="h-full antialiased"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" as="image" imageSrcSet="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=16&amp;q=75 16w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=32&amp;q=75 32w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=48&amp;q=75 48w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=64&amp;q=75 64w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=96&amp;q=75 96w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=128&amp;q=75 128w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=256&amp;q=75 256w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=384&amp;q=75 384w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=640&amp;q=75 640w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=750&amp;q=75 750w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=828&amp;q=75 828w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=1080&amp;q=75 1080w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=1200&amp;q=75 1200w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=1920&amp;q=75 1920w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=2048&amp;q=75 2048w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=3840&amp;q=75 3840w" imageSizes="2.25rem" fetchPriority="high"/><link rel="stylesheet" href="/_next/static/css/9d8f288a99c54fb3.css" crossorigin="" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-113544170b8b14d7.js" crossorigin=""/><script src="/_next/static/chunks/de8a8aed-ff24f23ca546a20c.js" async="" crossorigin=""></script><script src="/_next/static/chunks/362-edde6a9467fb7f3f.js" async="" crossorigin=""></script><script src="/_next/static/chunks/main-app-dca2b37e6b098eb8.js" async="" crossorigin=""></script><script src="/_next/static/chunks/736-93d26bf9f492bada.js" async=""></script><script src="/_next/static/chunks/545-972397648c423446.js" async=""></script><script src="/_next/static/chunks/871-e93f475163439fcd.js" async=""></script><script src="/_next/static/chunks/app/layout-58152a9375fe786b.js" async=""></script><script src="/_next/static/chunks/app/posts/page-6d06c0c42f2ef9eb.js" async=""></script><title>Serverless Back-End for React - Your Introduction to Serverless Architecture - Spencer Sharp</title><meta name="description" content="I’m Spencer, a software designer and entrepreneur based in New York City. I’m the founder and CEO of Planetaria, where we develop technologies that empower regular people to explore space on their own terms."/><link rel="alternate" type="application/rss+xml" href="undefined/feed.xml"/><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" crossorigin="" noModule=""></script></head><body class="flex h-full"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script><div class="flex w-full"><div class="relative flex w-full flex-col"><header class="pointer-events-none relative z-50 flex flex-none flex-col" style="height:var(--header-height);margin-bottom:var(--header-mb)"><div class="top-0 z-10 h-16 pt-6" style="position:var(--header-position)"><div class="sm:px-8 top-[var(--header-top,theme(spacing.6))] w-full" style="position:var(--header-inner-position)"><div class="mx-auto w-full max-w-7xl lg:px-8"><div class="relative px-4 sm:px-8 lg:px-12"><div class="mx-auto max-w-2xl lg:max-w-5xl"><div class="relative flex gap-4"><div class="flex flex-1"><div class="h-10 w-10 rounded-full bg-white/90 p-0.5 shadow-lg shadow-zinc-800/5 ring-1 ring-zinc-900/5 backdrop-blur dark:bg-zinc-800/90 dark:ring-white/10"><a aria-label="Home" class="pointer-events-auto" href="/"><img alt="" fetchPriority="high" width="1000" height="1000" decoding="async" data-nimg="1" class="rounded-full bg-zinc-100 object-cover dark:bg-zinc-800 h-9 w-9" style="color:transparent" sizes="2.25rem" srcSet="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=16&amp;q=75 16w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=32&amp;q=75 32w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=48&amp;q=75 48w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=64&amp;q=75 64w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=96&amp;q=75 96w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=128&amp;q=75 128w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=256&amp;q=75 256w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=384&amp;q=75 384w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=640&amp;q=75 640w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=750&amp;q=75 750w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=828&amp;q=75 828w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=1080&amp;q=75 1080w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=1200&amp;q=75 1200w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=1920&amp;q=75 1920w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=2048&amp;q=75 2048w, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=3840&amp;q=75 3840w" src="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Favatar.6206df77.jpg&amp;w=3840&amp;q=75"/></a></div></div><div class="flex flex-1 justify-end md:justify-center"><nav class="pointer-events-auto hidden md:block"><ul class="flex rounded-full bg-white/90 px-3 text-sm font-medium text-zinc-800 shadow-lg shadow-zinc-800/5 ring-1 ring-zinc-900/5 backdrop-blur dark:bg-zinc-800/90 dark:text-zinc-200 dark:ring-white/10"><li><a class="relative block px-3 py-2 transition hover:text-teal-500 dark:hover:text-teal-400" href="/about">About</a></li><li><a class="relative block px-3 py-2 transition hover:text-teal-500 dark:hover:text-teal-400" href="/posts">Blog</a></li><li><a class="relative block px-3 py-2 transition hover:text-teal-500 dark:hover:text-teal-400" href="/projects">Projects</a></li></ul></nav></div><div class="flex justify-end md:flex-1"><div class="pointer-events-auto"><button class="inline-flex items-center justify-center text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 hover:bg-accent hover:text-accent-foreground rounded-md h-8 w-8 px-0" type="button" id="radix-:R75la:" aria-haspopup="menu" aria-expanded="false" data-state="closed"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0"><circle cx="12" cy="12" r="4"></circle><path d="M12 3v1"></path><path d="M12 20v1"></path><path d="M3 12h1"></path><path d="M20 12h1"></path><path d="m18.364 5.636-.707.707"></path><path d="m6.343 17.657-.707.707"></path><path d="m5.636 5.636.707.707"></path><path d="m17.657 17.657.707.707"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="absolute rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg><span class="sr-only">Toggle theme</span></button></div></div></div></div></div></div></div></div></header><main class="flex-auto"><div class="sm:px-8 post mt-16 lg:mt-32"><div class="mx-auto w-full max-w-7xl lg:px-8"><div class="relative px-4 sm:px-8 lg:px-12"><div class="mx-auto max-w-2xl lg:max-w-5xl"><div class="xl:relative"><div class="mx-auto max-w-2xl"><article><header class="flex flex-col"><h1 class="text-4xl font-bold font-bold tracking-tight sm:text-5xl">Serverless Back-End for React - Your Introduction to Serverless Architecture</h1><div class="flex gap-3 pt-1"><time dateTime="2018-01-29" class="text-muted-foreground order-first flex items-center pr-2 text-base"><span class="h-4 w-0.5 rounded-full bg-zinc-200 dark:bg-zinc-500"></span><span class="ml-3">January 29, 2018</span></time><span class="text-muted-foreground">-</span><span class="text-muted-foreground/80">serverless</span><span class="text-muted-foreground/80">react</span><span class="text-muted-foreground/80">aws</span></div><div class="text-accent-foreground pt-3 text-sm italic">~<!-- -->16 min read</div></header><div class="mt-8 prose dark:prose-invert" data-mdx-content="true"><div><p>What's the opposite of the boy who cried wolf? The boy who cried that something amazing was coming? The boy who cried free pizza?</p>
<p>Serverless architecture might be the free pizza equivalent of web technologies in terms of how amazing it is. It's still very new tech, but the more I learn about it and use it, the more I am convinced that it's the future of web development.</p>
<p>In this post:</p>
<p>I'm going to go over what serverless architecture is and how using it differs from working with a traditional web framework. I'll also go over the benefits of serverless.</p>
<p>Then, I'll show you how you can make and deploy a simple serverless back-end for a React app using <a href="https://aws.amazon.com/lambda/">AWS Lambda</a> (Amazons's serverless platform).</p>
<p>And finally, to wrap it up, I'll go over some of the drawbacks of the serverless architecture.</p>
<p><em>Side note: I'm going to be using Amazon's platform for all of the examples in this post, but be aware that there are other serverless providers out there. The implementation details are going to be different depending on which one you use.</em></p>
<p>Let's get started!</p>
<h2 id="what-is-serverless"><a aria-hidden="true" tabindex="-1" href="#what-is-serverless"><a href="#what-is-serverless" style="margin-right: 10px">#</a></a>What is serverless?</h2>
<p>Okay, okay, technically the term serverless is a little misleading. The term serverless refers to FaaS or Function as a Service. We call it serverless because, although these functions still run on a server somewhere, you don't have to pay for, set up, or maintain a server yourself.</p>
<p>FaaS is a form of <a href="https://www.avantica.net/blog/event-based-computing-aws-lambda">event based computing</a>. Basically, you configure functions to be triggered by specific events. These functions are executed in little (or big) containers containing all of the dependencies they need to run.</p>
<p>Here is the cool part — these functions can be triggered by <a href="http://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html">all sorts of events</a>.</p>
<p>Here are a few of the events AWS Lambda can be triggered by:</p>
<ul>
<li>Amazon S3 Events — like when an object is added or deleted from S3.</li>
<li>Amazon Simple Email Service — when you receive an email.</li>
<li>Amazon Alexa — yes, you can trigger functions by talking to Alexa.</li>
<li>Amazon DynamoDB — trigger when data changes in your database.</li>
<li>Scheduled Events — self explanatory.</li>
<li>Amazon API Gateway — the Holy Grail!</li>
</ul>
<p>Amazon API Gateway! You can trigger these events using an API. Aaaaand, not only can you trigger a function with an API request, that function can send back a response! That's a back-end!</p>
<p>When you break down any web framework, even big ones like Rails, they all boil down each request to the execution and return value of one function. In the case of Rails, each request is mapped to one controller action, and all of the rest of the code is just helping the controller build the response.</p>
<p>It seems a little strange at first to think about web apps in terms of individual functions, but all of the other parts of the framework are there, they are just being handled by the infastructure.</p>
<p>A good example of this is the routing. In serverless you use a configuration file to tell the infastructure which API events to connect to which functions, so none of your actual code gets involved in the routing.</p>
<h2 id="why-serverless"><a aria-hidden="true" tabindex="-1" href="#why-serverless"><a href="#why-serverless" style="margin-right: 10px">#</a></a>Why Serverless</h2>
<p><strong>Cost</strong><br>
One of the biggest benefits of serverless is cost. You only pay for the request and runtime of the function. This means no more paying for idle servers. This ends up saving some companies a lot of money.</p>
<p><strong>Scalability</strong><br>
Serverless solves most scaling problems because each function is its own little microservice that can scale automatically by the provider.</p>
<p><em>Some of these other benefits are pretty subjective, but they come up frequently in discussions of serverless online.</em></p>
<p><strong>Time to Market</strong><br>
One claimed benefit is a faster time to market. This actually makes sense. You save a lot of time not having to worry about dev ops, and some of the things you used to have to write code for are handled by the infastructure, leaving you more time to develop the important parts of your application.</p>
<p><strong>Decreased Software Complexity</strong><br>
Of course it's still possible to write bad, tightly coupled code in serverless, but splitting your application into distinct functions helps you write better, loosely coupled code, leading to less complex software.</p>
<p><strong>Shorter Release Cycles</strong><br>
If everything is loosely coupled, it can mean shorter release cycles.</p>
<p><strong>Industry Direction</strong><br>
Another <strong>why</strong> is the fact that this seems to be the way the industry is heading. For a while now, the industry has been trending hard towards bigger front-ends. As front-end frameworks like Angular and React have been doing more and more of the heavy lifting for the client, the back-ends for web apps have been shrinking. Serverless seems to be testing just how small a back-end can be.</p>
<h2 id="how"><a aria-hidden="true" tabindex="-1" href="#how"><a href="#how" style="margin-right: 10px">#</a></a>How</h2>
<p>Here is the moment you've been waiting for!</p>
<p>In preparation for this post, I built a little React app called Business Cardistry. The app lets people design colorful business cards.</p>
<p><a href="http://cardistry.nmajor.com">Demo</a> | <a href="https://github.com/nmajor/business-cardistry-client">Source</a></p>
<p>Now, I want this app to let users actually download PDFs of their business card design. To do that, I am going to need a little back-end processing. Specifically, I want one endpoint that will receive the HTML of the business card design and return a URL the user can use to download a PDF of the design.</p>
<p>Before we begin, let's take a moment to appreciate the fact that we are going to be sending HTML <em>from the client</em> to the back-end. lol.</p>
<p>Here is our roadmap:</p>
<ul>
<li>Set up and create a new project</li>
<li>Deploy and send a test request</li>
<li>Set up an S3 Bucket</li>
<li>Code our function</li>
<li>Testing and final deployment</li>
</ul>
<p>Let's get started...</p>
<h3 id="set-up-and-create-a-new-project"><a aria-hidden="true" tabindex="-1" href="#set-up-and-create-a-new-project"><a href="#set-up-and-create-a-new-project" style="margin-right: 10px">#</a></a>Set up and Create a New Project</h3>
<p>The Serverless Toolkit over at <a href="https://serverless.com">serverless.com</a> has an amazing framework with incredible documentation, and that is what we are going to be using today.</p>
<p>You should already have <code>node v6.5.0</code> or higher installed.</p>
<p>First, install the serverless CLI: <code>npm install -g serverless</code>.</p>
<p>Then, follow <a href="https://serverless.com/framework/docs/providers/aws/guide/credentials/">these instructions</a> to set up your AWS account and credentials.</p>
<p>After following those instructions, you should have an Access Key ID, and a Secret Access Key, and both should be added to your shell environment under the variable names <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code>. This is where the serverless CLI looks for credentials when deploying.</p>
<p>Now that you have everything set up, let's create our back-end by running this command:</p>
<pre><code>serverless create --template aws-nodejs --path business-cardistry
</code></pre>
<p>This should create a new folder for us called <code>business-cardistry</code>. Let's go into that folder and have a look around.</p>
<pre><code>$ cd business-cardistry
$ ls -lah
total 24
drwxr-xr-x    5 nmajor  staff   160B Dec 27 13:37 .
drwxr-xr-x  110 nmajor  staff   3.4K Dec 27 13:37 ..
-rw-r--r--    1 nmajor  staff    86B Dec 27 13:37 .gitignore
-rw-r--r--    1 nmajor  staff   466B Dec 27 13:37 handler.js
-rw-r--r--    1 nmajor  staff   2.8K Dec 27 13:37 serverless.yml
</code></pre>
<p>As you can see, aside from <code>.gitignore</code>, we only have two files, <code>handler.js</code> and <code>serverless.yml</code>. Later, this file structure can grow into any structure we need to keep our code organized, but everything comes back to these two files.</p>
<p>The best way to learn how these files work is to dive in and change them a bit to see how they work.</p>
<p>I opened up <code>serverless.yml</code> and removed all of the comments, so now we have something like this (I added some annotations):</p>
<pre><code># serverless.yml

service: business-cardistry # Name of our service

provider:
  name: aws # AWS is our FaaS provider
  runtime: nodejs6.10 # The language our functions are using

functions:  # This is our list of functions
  hello:  # We have a function named hello
    handler: handler.hello  # references a function called hello in handler.js
</code></pre>
<p>Let's modify our <code>hello</code> function by renaming it to <code>pdf</code> and connecting it to an API event. We do that by modifying our <code>functions</code> section to look like this:</p>
<pre><code>functions:
  pdf:
    handler: handler.pdf
    events:
      - http:
          path: pdf
          method: post
</code></pre>
<p>As you can see, we added an <code>events</code> level to our <code>hello</code> section. We set the path to <code>pdf</code> and the method to <code>post</code>. This means we can trigger this event by sending a post request to <em>some-url-goes-here/pdf</em>. It looks a lot like a routing system in a traditional web framework, but again, it's being handled at the infrastructure level.</p>
<p>Now, let's take a look at <code>handler.js</code>.</p>
<pre><code># handler.js
'use strict';

module.exports.hello = (event, context, callback) => {
  const response = {
    statusCode: 200,
    body: JSON.stringify({
      message: 'Go Serverless v1.0! Your function executed successfully!',
      input: event,
    }),
  };

  callback(null, response);
};
</code></pre>
<p>Again, let's modify it by changing <code>hello</code> to <code>pdf</code>. Let's also change the body to only return the message. Now, the file should look like this:</p>
<pre><code>'use strict';

module.exports.pdf = (event, context, callback) => {
  const response = {
    statusCode: 200,
    body: JSON.stringify({
      message: 'Go Serverless v1.0! Your function executed successfully!',
    }),
  };

  callback(null, response);
};
</code></pre>
<p>Alright, now <code>serverless.yml</code> defines a function called <code>pdf</code>, which is connected to the <code>pdf</code> function in <code>handler.js</code>. We now should have everything we need to deploy and send a request.</p>
<h3 id="deploy-and-send-a-test-request"><a aria-hidden="true" tabindex="-1" href="#deploy-and-send-a-test-request"><a href="#deploy-and-send-a-test-request" style="margin-right: 10px">#</a></a>Deploy and Send a Test Request</h3>
<p>There actually isn't any straightforward way to run your serverless script locally, so we actually need to deploy it to test it out.</p>
<p>You can deploy it with the command:</p>
<pre><code>serverless deploy -s dev
</code></pre>
<p>The <code>-s dev</code> part tells it to set the stage to dev. The stage is how we differentiate production code from development code. We will deploy it to the production stage when everything is working.</p>
<p>You should see something like this when you deploy:</p>
<pre><code>$ serverless deploy -s dev
Serverless: Packaging service...
Serverless: Excluding development dependencies...
Serverless: Uploading CloudFormation file to S3...
Serverless: Uploading artifacts...
Serverless: Uploading service .zip file to S3 (327 B)...
Serverless: Validating template...
Serverless: Updating Stack...
Serverless: Checking Stack update progress...
...............................
Serverless: Stack update finished...
Service Information
service: business-cardistry
stage: dev
region: us-east-1
stack: business-cardistry-dev
api keys:
  None
endpoints:
  POST - https://o20pczjzbl.execute-api.us-east-1.amazonaws.com/dev/pdf
functions:
  pdf: business-cardistry-dev-pdf
</code></pre>
<p>There is the URL for our endpoint. Let's try it out!</p>
<pre><code>$ curl -X POST https://o20pczjzbl.execute-api.us-east-1.amazonaws.com/dev/pdf
{"message":"Go Serverless v1.0! Your function executed successfully!"}
</code></pre>
<p>It works! I'm still blown away by how easy that is.</p>
<h3 id="set-up-an-s3-bucket"><a aria-hidden="true" tabindex="-1" href="#set-up-an-s3-bucket"><a href="#set-up-an-s3-bucket" style="margin-right: 10px">#</a></a>Set Up an S3 Bucket</h3>
<p>Because we are going to be sending back a link that the user can use to download their business card, we need to upload the PDFs to S3. Let's quickly set up an S3 bucket with the proper permissions.</p>
<p>First, let's talk about permissions. Lambdas have an execution role that they assume when they run. The permissions the execution role has will determine which AWS services (like S3) our Lambda function can access.</p>
<p>By default, every new Lambda function gets its own new role, we need to first get the Role ARN of the new role that was created for our function. The Role ARN is the ID of the role that we will use to give that role access to S3.</p>
<p>Later, when we deploy a production function, we will change the execution role of the production function to match dev role which will give the production function the same access that the dev function has.</p>
<p>But first, we need that Role ARN.</p>
<p>Log in to your AWS console and go to the Lambda service.</p>
<p>You should see our function on the list. Go ahead and click it.</p>
<p><img src="https://cdn.filestackcontent.com/HjebSOAcRXqJCPhLBkmo" alt="skitch.png"></p>
<p>Scroll down to the section that says "Execution Role" and you should see the role that is currently selected. Don't change it — we just needed to see the name of the role.</p>
<p><img src="https://cdn.filestackcontent.com/C5ZeY2CVTzGROwYIuVnQ" alt="skitch.png"></p>
<p>Now, get the Role ARN by going to the IAM service in the AWS console, click on "Roles" in the sidebar, and select the role for the function. You should see the "Role ARN" at the top of the role page.</p>
<p>Or, if you have the AWS CLI installed, you can get the Role ARN by running this command:</p>
<pre><code>aws iam get-role --role-name name-of-role
</code></pre>
<p>The Role ARN should look something like this:</p>
<p><code>arn:aws:iam::525814828111:role/business-cardistry-dev-us-east-1-lambdaRole</code></p>
<p>Now, go to the S3 service.</p>
<p>Click "Create Bucket."</p>
<p><img src="https://cdn.filestackcontent.com/nJLo9YqTFmVxKwzAlIrA" alt="skitch.png"></p>
<p>Give the bucket a name but leave everything else at its default value by clicking "Next," "Next," "Next," "Create Bucket."</p>
<p><img src="https://cdn.filestackcontent.com/3PGjDW4tTFedF6jGQQQM" alt="skitch.png"></p>
<p>Then, click on your newly created bucket.</p>
<p>Select the Permissions tab, then Bucket Policy.</p>
<p><img src="https://cdn.filestackcontent.com/tMCgzh96Tv2Y6TsODsZv" alt="skitch.png"></p>
<p>Paste this into the editor. Be sure to replace <em>role-goes-here</em> with the Role ARN.</p>
<pre><code>{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "AllowPutForAllS3TestfilesLambda",
            "Effect": "Allow",
            "Principal": {
                "AWS": "role-goes-here"
            },
            "Action": "s3:*",
            "Resource": "arn:aws:s3:::business-cardistry/*"
        }
    ]
}
</code></pre>
<p>Alright, this policy allows our custom role to perform all S3 actions on our new S3 bucket. S3 should be good to go!</p>
<h3 id="code-our-function"><a aria-hidden="true" tabindex="-1" href="#code-our-function"><a href="#code-our-function" style="margin-right: 10px">#</a></a>Code Our Function</h3>
<p>Okay, now we can get to coding. Let's make our <code>pdf</code> function. It needs to receive some HTML, process it into a PDF file buffer, then then upload that buffer to S3.</p>
<p>Let's initialize npm and add some dependencies.</p>
<pre><code>$ npm init -y
$ npm install --save html-pdf aws-sdk shortid
</code></pre>
<p>The <code>html-pdf</code> library we are using requires the program <code>phantomjs</code> to be available as an executable binary. Normally, if we were running this script on a server, we would just install <code>phantomjs</code> on the server. Because this is serverless, we need to make sure that the runtime context has access to the <code>phantomjs</code> executable binary.</p>
<p>The way I handled this was to <a href="http://phantomjs.org/download.html">download the binary</a> and put it into a <code>bin</code> folder in the project root.</p>
<p>Then, I made sure to add this to the serverless.yml file:</p>
<pre><code>package:
  include:
    - bin/phantomjs
</code></pre>
<p>Now, when the function is deployed, it grabs that binary and uploads it while preserving its permissions and making it available in the runtime environment of the function.</p>
<p>Okay. Let's get to the code. Here is what my <code>pdf</code> function looks like:</p>
<pre><code>'use strict';

const pdf = require('html-pdf');
const path = require('path');
const AWS = require('aws-sdk');
const shortid = require('shortid');

module.exports.pdf = (event, context, callback) => {
  const html = event.body;
  pdf.create(html, {
    height: '200px',
    width: '350px',
    phantomPath: path.resolve(process.env.LAMBDA_TASK_ROOT, 'bin/phantomjs'),
  }).toBuffer((err, buffer) => {
    if (err) return console.log(err);

    const fileKey = `cards/${shortid.generate()}.pdf`;
    const bucket = 'business-cardistry';

    const s3 = new AWS.S3();
    s3.putObject({
      Bucket: bucket,
      Key: fileKey,
      Body: buffer,
      ACL: 'public-read'
    },function (resp) {
      const fileUrl = s3.getSignedUrl('getObject', {
        Bucket: bucket,
        Key: fileKey,
        Expires: 60,
      });

      callback(null, {
        statusCode: 200,
        headers: {
          'Content-Type' : 'application/json',
          'Access-Control-Allow-Origin' : '*',
        },
        body: JSON.stringify({ fileUrl }),
      });
    });
  });
};
</code></pre>
<p>I'm not going to go into the code too deeply, but it takes the body of the request and uses it to generate a PDF buffer. It then uploads the buffer to S3 and returns a signed URL for the uploaded object.</p>
<p>You see the line that says <code>path.resolve(process.env.LAMBDA_TASK_ROOT, 'bin/phantomjs')</code>? This is how we reference that phantomjs executable binary.</p>
<p>You'll notice that we don't need to specify any AWS credentials. It automatically gets the credentials from the execution role.</p>
<h3 id="testing-and-final-deployment"><a aria-hidden="true" tabindex="-1" href="#testing-and-final-deployment"><a href="#testing-and-final-deployment" style="margin-right: 10px">#</a></a>Testing and Final Deployment</h3>
<p>Since this endpoint simply receives HTML and returns a filepath, we should still be able to test it with a curl command. First, let's deploy to dev again.</p>
<pre><code>serverless deploy -s dev
</code></pre>
<p>The above deploy command will deploy the whole project. To deploy only one function, you can use the command:</p>
<pre><code>serverless deploy function -f pdf -s dev
</code></pre>
<p>If you run into any errors, you can check the logs for the <code>pdf</code> function with this command:</p>
<pre><code>logs -f pdf -s dev
</code></pre>
<p>Now we can test it by sending another curl request with a string of HTML</p>
<pre><code>$ curl -d '&#x3C;h1>Hello PDF!&#x3C;/h1>' -X POST https://o20pczjzbl.execute-api.us-east-1.amazonaws.com/dev/pdf
{"fileUrl":"https://business-cardis...j2hJHSBQ%3D%3D"}
</code></pre>
<p>It works! When I paste in the fileUrl link into a browser, it downloads a PDF that looks like this:</p>
<p><img src="https://cdn.filestackcontent.com/VKbRNpBATGGvLVGmV9W7" alt="SJ5Orpb7M-1.jpg"></p>
<p>Which is exactly what we expect.</p>
<p>So now, let's deploy in production!</p>
<pre><code>$ serverless deploy -s production
Serverless: Packaging service...
Serverless: Excluding development dependencies...
Serverless: Creating Stack...
Serverless: Checking Stack create progress...
.....
Serverless: Stack create finished...
Serverless: Uploading CloudFormation file to S3...
Serverless: Uploading artifacts...
Serverless: Uploading service .zip file to S3 (35.56 MB)...
Serverless: Validating template...
Serverless: Updating Stack...
Serverless: Checking Stack update progress...
..............................
Serverless: Stack update finished...
Service Information
service: business-cardistry
stage: production
region: us-east-1
stack: business-cardistry-production
api keys:
  None
endpoints:
  POST - https://8103v1xvqk.execute-api.us-east-1.amazonaws.com/production/pdf
functions:
  pdf: business-cardistry-production-pdf
</code></pre>
<p>Now, this created a whole new function in Lambda, so remember all of that talk about execution roles? We need to change the execution role of the production function to match the role of the dev function. That way the production function will have access to S3 as well..</p>
<p>So go back to the Lambda page in AWS, click on the new production function that was just created, and change the Execution Role to the dev role:</p>
<p><img src="https://cdn.filestackcontent.com/xji2HYMZQySyeb74aIL7" alt="skitch.png"></p>
<p>Once that's done, we can double check the production endpoint.</p>
<pre><code>$ curl -d '&#x3C;h1>Hello PDF!&#x3C;/h1>' -X POST https://8103v1xvqk.execute-api.us-east-1.amazonaws.com/production/pdf
{"fileUrl":"https://business-cardis...j2hJHSBQ%3D%3D"}
</code></pre>
<p>Aaaaaand it works! Now after modifying the request URL in my React code, my app is complete!</p>
<p>Be sure to check out <a href="http://cardistry.nmajor.com/">cardistry.nmajor.com</a> to see it in action.</p>
<p>I know this was just a simple example with one endpoint, but this same process could be used to build dozens of endpoints for almost any app. I hope this gives you a good idea of what's possible with serverless, and how easy and powerful it can be!</p>
<h2 id="limitations-and-drawbacks-of-serverless"><a aria-hidden="true" tabindex="-1" href="#limitations-and-drawbacks-of-serverless"><a href="#limitations-and-drawbacks-of-serverless" style="margin-right: 10px">#</a></a>Limitations and Drawbacks of Serverless</h2>
<p>As awesome as serverless is, there are some limitations and drawbacks:</p>
<p><strong>Latency</strong><br>
Although AWS Lambda is designed to execute functions in milliseconds, you do have some added latency when using serverless. However, we are talking about a few hundred added milliseconds. For most web applications, it's not going to be an issue, but if latency is really important for your project, it's something you are going to want to consider.</p>
<p><strong>Vendor Lock-in</strong>
Because serverless relies so heavily on the infrastructure and the supporting services, but you may need to re-write large parts of your application to move it to a different provider.</p>
<p><strong>Black Box</strong><br>
Many of the parts of your application are out of your control, so when things go wrong or if you hit an edge use-case with your app, you have little control over your ability to resolve it yourself.</p>
<p><strong>New Tech</strong><br>
Serverless is still in its infancy, so, as with any new technology, great care should be used when deciding whether or not to jump on the bandwagon early.</p>
<h2 id="conclusion"><a aria-hidden="true" tabindex="-1" href="#conclusion"><a href="#conclusion" style="margin-right: 10px">#</a></a>Conclusion</h2>
<p>I believe serverless is the next big thing in web development. So much in web development is the same. Every framework solves many of the same problems in the same way. Serverless is solving those problems at the infrastructural level, leaving you free to work on the important and different parts of your App.</p>
<p>Combine that with cost and scalability benefits, and the fact that there are so many amazing front-end frameworks like React, and the days of traditional back-end frameworks are numbered.</p>
<h2 id="other-resources"><a aria-hidden="true" tabindex="-1" href="#other-resources"><a href="#other-resources" style="margin-right: 10px">#</a></a>Other Resources:</h2>
<ul>
<li><a href="https://serverless-stack.com/">serverless-stack.com</a> — A comprehensive tutorial on building and deploying full-stack apps using Serverless and React on AWS.</li>
<li><a href="https://serverless.com/">serverless.com</a> — Great documentation, community, and other resources.</li>
</ul></div></div></article></div></div></div></div></div></div></main><footer class="mt-32 flex-none"><div class="sm:px-8"><div class="mx-auto w-full max-w-7xl lg:px-8"><div class="pb-16 pt-10"><div class="relative px-4 sm:px-8 lg:px-12"><div class="mx-auto max-w-2xl lg:max-w-5xl"><div class="flex flex-col items-center justify-between gap-6 sm:flex-row"><div class="flex flex-wrap justify-center gap-x-6 gap-y-1 text-sm font-medium text-zinc-800 dark:text-zinc-200"><a class="transition hover:text-teal-500 dark:hover:text-teal-400" href="/about">About</a><a class="transition hover:text-teal-500 dark:hover:text-teal-400" href="/projects">Projects</a><a class="transition hover:text-teal-500 dark:hover:text-teal-400" href="/speaking">Speaking</a><a class="transition hover:text-teal-500 dark:hover:text-teal-400" href="/uses">Uses</a></div><p class="text-sm text-zinc-400 dark:text-zinc-500">© <!-- -->2023<!-- --> Spencer Sharp. All rights reserved.</p></div></div></div></div></div></div></footer></div></div><script src="/_next/static/chunks/webpack-113544170b8b14d7.js" crossorigin="" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/_next/static/css/9d8f288a99c54fb3.css\",\"style\",{\"crossOrigin\":\"\"}]\n0:\"$L2\"\n"])</script><script>self.__next_f.push([1,"3:I[7483,[],\"\"]\n5:I[655,[],\"\"]\n6:I[2286,[\"736\",\"static/chunks/736-93d26bf9f492bada.js\",\"545\",\"static/chunks/545-972397648c423446.js\",\"871\",\"static/chunks/871-e93f475163439fcd.js\",\"185\",\"static/chunks/app/layout-58152a9375fe786b.js\"],\"ThemeProvider\"]\n7:I[7019,[\"736\",\"static/chunks/736-93d26bf9f492bada.js\",\"545\",\"static/chunks/545-972397648c423446.js\",\"871\",\"static/chunks/871-e93f475163439fcd.js\",\"185\",\"static/chunks/app/layout-58152a9375fe786b.js\"],\"Header\"]\n8:I[3849,[],\"\"]\n9:I[8656,[],\"\"]\na:I[4736,[\"736\",\"s"])</script><script>self.__next_f.push([1,"tatic/chunks/736-93d26bf9f492bada.js\",\"991\",\"static/chunks/app/posts/page-6d06c0c42f2ef9eb.js\"],\"\"]\n"])</script><script>self.__next_f.push([1,"2:[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/9d8f288a99c54fb3.css\",\"precedence\":\"next\",\"crossOrigin\":\"\"}]],[\"$\",\"$L3\",null,{\"buildId\":\"AzO8YmqLI-jVS4hv3vlbF\",\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/posts/2018-01-29-serverless-back-end-for-react-your-introduction-to-serverless-architecture\",\"initialTree\":[\"\",{\"children\":[\"posts\",{\"children\":[[\"slug\",\"2018-01-29-serverless-back-end-for-react-your-introduction-to-serverless-architecture\",\"d\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":\\\"2018-01-29-serverless-back-end-for-react-your-introduction-to-serverless-architecture\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialHead\":[false,\"$L4\"],\"globalErrorComponent\":\"$5\",\"children\":[null,[\"$\",\"html\",null,{\"lang\":\"en\",\"className\":\"h-full antialiased\",\"suppressHydrationWarning\":true,\"children\":[\"$\",\"body\",null,{\"className\":\"flex h-full\",\"children\":[\"$\",\"$L6\",null,{\"attribute\":\"class\",\"defaultTheme\":\"system\",\"enableSystem\":true,\"disableTransitionOnChange\":true,\"children\":[\"$\",\"div\",null,{\"className\":\"flex w-full\",\"children\":[\"$\",\"div\",null,{\"className\":\"relative flex w-full flex-col\",\"children\":[[\"$\",\"$L7\",null,{}],[\"$\",\"main\",null,{\"className\":\"flex-auto\",\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[\"$\",\"div\",null,{\"className\":\"sm:px-8 flex h-full items-center pt-16 sm:pt-32\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto w-full max-w-7xl lg:px-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"relative px-4 sm:px-8 lg:px-12\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-2xl lg:max-w-5xl\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center\",\"children\":[[\"$\",\"p\",null,{\"className\":\"text-base font-semibold text-zinc-400 dark:text-zinc-500\",\"children\":\"404\"}],[\"$\",\"h1\",null,{\"className\":\"mt-4 text-4xl font-bold tracking-tight text-zinc-800 dark:text-zinc-100 sm:text-5xl\",\"children\":\"Page not found\"}],[\"$\",\"p\",null,{\"className\":\"mt-4 text-base text-zinc-600 dark:text-zinc-400\",\"children\":\"Sorry, we couldn’t find the page you’re looking for.\"}],[\"$\",\"$La\",null,{\"href\":\"/\",\"children\":[\"$\",\"button\",null,{\"className\":\"inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-primary text-primary-foreground hover:bg-primary/90 h-10 px-4 py-2 mt-4\",\"children\":\"Go back home\"}]}]]}]}]}]}]}],\"notFoundStyles\":[],\"childProp\":{\"current\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"posts\",\"children\",[\"slug\",\"2018-01-29-serverless-back-end-for-react-your-introduction-to-serverless-architecture\",\"d\"],\"children\"],\"loading\":\"$undefined\",\"loadingStyles\":\"$undefined\",\"loadingScripts\":\"$undefined\",\"hasLoading\":false,\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\",\"childProp\":{\"current\":[\"$Lb\",\"$Lc\",null],\"segment\":\"__PAGE__?{\\\"slug\\\":\\\"2018-01-29-serverless-back-end-for-react-your-introduction-to-serverless-architecture\\\"}\"},\"styles\":null}],\"segment\":[\"slug\",\"2018-01-29-serverless-back-end-for-react-your-introduction-to-serverless-architecture\",\"d\"]},\"styles\":null}],\"segment\":\"posts\"},\"styles\":null}]}],[\"$\",\"footer\",null,{\"className\":\"mt-32 flex-none\",\"children\":[\"$\",\"div\",null,{\"className\":\"sm:px-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto w-full max-w-7xl lg:px-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"pb-16 pt-10\",\"children\":[\"$\",\"div\",null,{\"className\":\"relative px-4 sm:px-8 lg:px-12\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-2xl lg:max-w-5xl\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center justify-between gap-6 sm:flex-row\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex flex-wrap justify-center gap-x-6 gap-y-1 text-sm font-medium text-zinc-800 dark:text-zinc-200\",\"children\":[[\"$\",\"$La\",null,{\"href\":\"/about\",\"className\":\"transition hover:text-teal-500 dark:hover:text-teal-400\",\"children\":\"About\"}],[\"$\",\"$La\",null,{\"href\":\"/projects\",\"className\":\"transition hover:text-teal-500 dark:hover:text-teal-400\",\"children\":\"Projects\"}],[\"$\",\"$La\",null,{\"href\":\"/speaking\",\"className\":\"transition hover:text-teal-500 dark:hover:text-teal-400\",\"children\":\"Speaking\"}],[\"$\",\"$La\",null,{\"href\":\"/uses\",\"className\":\"transition hover:text-teal-500 dark:hover:text-teal-400\",\"children\":\"Uses\"}]]}],[\"$\",\"p\",null,{\"className\":\"text-sm text-zinc-400 dark:text-zinc-500\",\"children\":[\"© \",2023,\" Spencer Sharp. All rights reserved.\"]}]]}]}]}]}]}]}]}]]}]}]}]}]}],null]}]]\n"])</script><script>self.__next_f.push([1,"d:T61f7,"])</script><script>self.__next_f.push([1,"\u003cp\u003eWhat's the opposite of the boy who cried wolf? The boy who cried that something amazing was coming? The boy who cried free pizza?\u003c/p\u003e\n\u003cp\u003eServerless architecture might be the free pizza equivalent of web technologies in terms of how amazing it is. It's still very new tech, but the more I learn about it and use it, the more I am convinced that it's the future of web development.\u003c/p\u003e\n\u003cp\u003eIn this post:\u003c/p\u003e\n\u003cp\u003eI'm going to go over what serverless architecture is and how using it differs from working with a traditional web framework. I'll also go over the benefits of serverless.\u003c/p\u003e\n\u003cp\u003eThen, I'll show you how you can make and deploy a simple serverless back-end for a React app using \u003ca href=\"https://aws.amazon.com/lambda/\"\u003eAWS Lambda\u003c/a\u003e (Amazons's serverless platform).\u003c/p\u003e\n\u003cp\u003eAnd finally, to wrap it up, I'll go over some of the drawbacks of the serverless architecture.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eSide note: I'm going to be using Amazon's platform for all of the examples in this post, but be aware that there are other serverless providers out there. The implementation details are going to be different depending on which one you use.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eLet's get started!\u003c/p\u003e\n\u003ch2 id=\"what-is-serverless\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#what-is-serverless\"\u003e\u003ca href=\"#what-is-serverless\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eWhat is serverless?\u003c/h2\u003e\n\u003cp\u003eOkay, okay, technically the term serverless is a little misleading. The term serverless refers to FaaS or Function as a Service. We call it serverless because, although these functions still run on a server somewhere, you don't have to pay for, set up, or maintain a server yourself.\u003c/p\u003e\n\u003cp\u003eFaaS is a form of \u003ca href=\"https://www.avantica.net/blog/event-based-computing-aws-lambda\"\u003eevent based computing\u003c/a\u003e. Basically, you configure functions to be triggered by specific events. These functions are executed in little (or big) containers containing all of the dependencies they need to run.\u003c/p\u003e\n\u003cp\u003eHere is the cool part — these functions can be triggered by \u003ca href=\"http://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html\"\u003eall sorts of events\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eHere are a few of the events AWS Lambda can be triggered by:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAmazon S3 Events — like when an object is added or deleted from S3.\u003c/li\u003e\n\u003cli\u003eAmazon Simple Email Service — when you receive an email.\u003c/li\u003e\n\u003cli\u003eAmazon Alexa — yes, you can trigger functions by talking to Alexa.\u003c/li\u003e\n\u003cli\u003eAmazon DynamoDB — trigger when data changes in your database.\u003c/li\u003e\n\u003cli\u003eScheduled Events — self explanatory.\u003c/li\u003e\n\u003cli\u003eAmazon API Gateway — the Holy Grail!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAmazon API Gateway! You can trigger these events using an API. Aaaaand, not only can you trigger a function with an API request, that function can send back a response! That's a back-end!\u003c/p\u003e\n\u003cp\u003eWhen you break down any web framework, even big ones like Rails, they all boil down each request to the execution and return value of one function. In the case of Rails, each request is mapped to one controller action, and all of the rest of the code is just helping the controller build the response.\u003c/p\u003e\n\u003cp\u003eIt seems a little strange at first to think about web apps in terms of individual functions, but all of the other parts of the framework are there, they are just being handled by the infastructure.\u003c/p\u003e\n\u003cp\u003eA good example of this is the routing. In serverless you use a configuration file to tell the infastructure which API events to connect to which functions, so none of your actual code gets involved in the routing.\u003c/p\u003e\n\u003ch2 id=\"why-serverless\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#why-serverless\"\u003e\u003ca href=\"#why-serverless\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eWhy Serverless\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eCost\u003c/strong\u003e\u003cbr\u003e\nOne of the biggest benefits of serverless is cost. You only pay for the request and runtime of the function. This means no more paying for idle servers. This ends up saving some companies a lot of money.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eScalability\u003c/strong\u003e\u003cbr\u003e\nServerless solves most scaling problems because each function is its own little microservice that can scale automatically by the provider.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eSome of these other benefits are pretty subjective, but they come up frequently in discussions of serverless online.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTime to Market\u003c/strong\u003e\u003cbr\u003e\nOne claimed benefit is a faster time to market. This actually makes sense. You save a lot of time not having to worry about dev ops, and some of the things you used to have to write code for are handled by the infastructure, leaving you more time to develop the important parts of your application.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDecreased Software Complexity\u003c/strong\u003e\u003cbr\u003e\nOf course it's still possible to write bad, tightly coupled code in serverless, but splitting your application into distinct functions helps you write better, loosely coupled code, leading to less complex software.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eShorter Release Cycles\u003c/strong\u003e\u003cbr\u003e\nIf everything is loosely coupled, it can mean shorter release cycles.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eIndustry Direction\u003c/strong\u003e\u003cbr\u003e\nAnother \u003cstrong\u003ewhy\u003c/strong\u003e is the fact that this seems to be the way the industry is heading. For a while now, the industry has been trending hard towards bigger front-ends. As front-end frameworks like Angular and React have been doing more and more of the heavy lifting for the client, the back-ends for web apps have been shrinking. Serverless seems to be testing just how small a back-end can be.\u003c/p\u003e\n\u003ch2 id=\"how\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#how\"\u003e\u003ca href=\"#how\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eHow\u003c/h2\u003e\n\u003cp\u003eHere is the moment you've been waiting for!\u003c/p\u003e\n\u003cp\u003eIn preparation for this post, I built a little React app called Business Cardistry. The app lets people design colorful business cards.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://cardistry.nmajor.com\"\u003eDemo\u003c/a\u003e | \u003ca href=\"https://github.com/nmajor/business-cardistry-client\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eNow, I want this app to let users actually download PDFs of their business card design. To do that, I am going to need a little back-end processing. Specifically, I want one endpoint that will receive the HTML of the business card design and return a URL the user can use to download a PDF of the design.\u003c/p\u003e\n\u003cp\u003eBefore we begin, let's take a moment to appreciate the fact that we are going to be sending HTML \u003cem\u003efrom the client\u003c/em\u003e to the back-end. lol.\u003c/p\u003e\n\u003cp\u003eHere is our roadmap:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSet up and create a new project\u003c/li\u003e\n\u003cli\u003eDeploy and send a test request\u003c/li\u003e\n\u003cli\u003eSet up an S3 Bucket\u003c/li\u003e\n\u003cli\u003eCode our function\u003c/li\u003e\n\u003cli\u003eTesting and final deployment\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLet's get started...\u003c/p\u003e\n\u003ch3 id=\"set-up-and-create-a-new-project\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#set-up-and-create-a-new-project\"\u003e\u003ca href=\"#set-up-and-create-a-new-project\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eSet up and Create a New Project\u003c/h3\u003e\n\u003cp\u003eThe Serverless Toolkit over at \u003ca href=\"https://serverless.com\"\u003eserverless.com\u003c/a\u003e has an amazing framework with incredible documentation, and that is what we are going to be using today.\u003c/p\u003e\n\u003cp\u003eYou should already have \u003ccode\u003enode v6.5.0\u003c/code\u003e or higher installed.\u003c/p\u003e\n\u003cp\u003eFirst, install the serverless CLI: \u003ccode\u003enpm install -g serverless\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThen, follow \u003ca href=\"https://serverless.com/framework/docs/providers/aws/guide/credentials/\"\u003ethese instructions\u003c/a\u003e to set up your AWS account and credentials.\u003c/p\u003e\n\u003cp\u003eAfter following those instructions, you should have an Access Key ID, and a Secret Access Key, and both should be added to your shell environment under the variable names \u003ccode\u003eAWS_ACCESS_KEY_ID\u003c/code\u003e and \u003ccode\u003eAWS_SECRET_ACCESS_KEY\u003c/code\u003e. This is where the serverless CLI looks for credentials when deploying.\u003c/p\u003e\n\u003cp\u003eNow that you have everything set up, let's create our back-end by running this command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eserverless create --template aws-nodejs --path business-cardistry\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis should create a new folder for us called \u003ccode\u003ebusiness-cardistry\u003c/code\u003e. Let's go into that folder and have a look around.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cd business-cardistry\n$ ls -lah\ntotal 24\ndrwxr-xr-x    5 nmajor  staff   160B Dec 27 13:37 .\ndrwxr-xr-x  110 nmajor  staff   3.4K Dec 27 13:37 ..\n-rw-r--r--    1 nmajor  staff    86B Dec 27 13:37 .gitignore\n-rw-r--r--    1 nmajor  staff   466B Dec 27 13:37 handler.js\n-rw-r--r--    1 nmajor  staff   2.8K Dec 27 13:37 serverless.yml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, aside from \u003ccode\u003e.gitignore\u003c/code\u003e, we only have two files, \u003ccode\u003ehandler.js\u003c/code\u003e and \u003ccode\u003eserverless.yml\u003c/code\u003e. Later, this file structure can grow into any structure we need to keep our code organized, but everything comes back to these two files.\u003c/p\u003e\n\u003cp\u003eThe best way to learn how these files work is to dive in and change them a bit to see how they work.\u003c/p\u003e\n\u003cp\u003eI opened up \u003ccode\u003eserverless.yml\u003c/code\u003e and removed all of the comments, so now we have something like this (I added some annotations):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# serverless.yml\n\nservice: business-cardistry # Name of our service\n\nprovider:\n  name: aws # AWS is our FaaS provider\n  runtime: nodejs6.10 # The language our functions are using\n\nfunctions:  # This is our list of functions\n  hello:  # We have a function named hello\n    handler: handler.hello  # references a function called hello in handler.js\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet's modify our \u003ccode\u003ehello\u003c/code\u003e function by renaming it to \u003ccode\u003epdf\u003c/code\u003e and connecting it to an API event. We do that by modifying our \u003ccode\u003efunctions\u003c/code\u003e section to look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunctions:\n  pdf:\n    handler: handler.pdf\n    events:\n      - http:\n          path: pdf\n          method: post\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs you can see, we added an \u003ccode\u003eevents\u003c/code\u003e level to our \u003ccode\u003ehello\u003c/code\u003e section. We set the path to \u003ccode\u003epdf\u003c/code\u003e and the method to \u003ccode\u003epost\u003c/code\u003e. This means we can trigger this event by sending a post request to \u003cem\u003esome-url-goes-here/pdf\u003c/em\u003e. It looks a lot like a routing system in a traditional web framework, but again, it's being handled at the infrastructure level.\u003c/p\u003e\n\u003cp\u003eNow, let's take a look at \u003ccode\u003ehandler.js\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# handler.js\n'use strict';\n\nmodule.exports.hello = (event, context, callback) =\u003e {\n  const response = {\n    statusCode: 200,\n    body: JSON.stringify({\n      message: 'Go Serverless v1.0! Your function executed successfully!',\n      input: event,\n    }),\n  };\n\n  callback(null, response);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAgain, let's modify it by changing \u003ccode\u003ehello\u003c/code\u003e to \u003ccode\u003epdf\u003c/code\u003e. Let's also change the body to only return the message. Now, the file should look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e'use strict';\n\nmodule.exports.pdf = (event, context, callback) =\u003e {\n  const response = {\n    statusCode: 200,\n    body: JSON.stringify({\n      message: 'Go Serverless v1.0! Your function executed successfully!',\n    }),\n  };\n\n  callback(null, response);\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlright, now \u003ccode\u003eserverless.yml\u003c/code\u003e defines a function called \u003ccode\u003epdf\u003c/code\u003e, which is connected to the \u003ccode\u003epdf\u003c/code\u003e function in \u003ccode\u003ehandler.js\u003c/code\u003e. We now should have everything we need to deploy and send a request.\u003c/p\u003e\n\u003ch3 id=\"deploy-and-send-a-test-request\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#deploy-and-send-a-test-request\"\u003e\u003ca href=\"#deploy-and-send-a-test-request\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eDeploy and Send a Test Request\u003c/h3\u003e\n\u003cp\u003eThere actually isn't any straightforward way to run your serverless script locally, so we actually need to deploy it to test it out.\u003c/p\u003e\n\u003cp\u003eYou can deploy it with the command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eserverless deploy -s dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e-s dev\u003c/code\u003e part tells it to set the stage to dev. The stage is how we differentiate production code from development code. We will deploy it to the production stage when everything is working.\u003c/p\u003e\n\u003cp\u003eYou should see something like this when you deploy:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ serverless deploy -s dev\nServerless: Packaging service...\nServerless: Excluding development dependencies...\nServerless: Uploading CloudFormation file to S3...\nServerless: Uploading artifacts...\nServerless: Uploading service .zip file to S3 (327 B)...\nServerless: Validating template...\nServerless: Updating Stack...\nServerless: Checking Stack update progress...\n...............................\nServerless: Stack update finished...\nService Information\nservice: business-cardistry\nstage: dev\nregion: us-east-1\nstack: business-cardistry-dev\napi keys:\n  None\nendpoints:\n  POST - https://o20pczjzbl.execute-api.us-east-1.amazonaws.com/dev/pdf\nfunctions:\n  pdf: business-cardistry-dev-pdf\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere is the URL for our endpoint. Let's try it out!\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ curl -X POST https://o20pczjzbl.execute-api.us-east-1.amazonaws.com/dev/pdf\n{\"message\":\"Go Serverless v1.0! Your function executed successfully!\"}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt works! I'm still blown away by how easy that is.\u003c/p\u003e\n\u003ch3 id=\"set-up-an-s3-bucket\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#set-up-an-s3-bucket\"\u003e\u003ca href=\"#set-up-an-s3-bucket\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eSet Up an S3 Bucket\u003c/h3\u003e\n\u003cp\u003eBecause we are going to be sending back a link that the user can use to download their business card, we need to upload the PDFs to S3. Let's quickly set up an S3 bucket with the proper permissions.\u003c/p\u003e\n\u003cp\u003eFirst, let's talk about permissions. Lambdas have an execution role that they assume when they run. The permissions the execution role has will determine which AWS services (like S3) our Lambda function can access.\u003c/p\u003e\n\u003cp\u003eBy default, every new Lambda function gets its own new role, we need to first get the Role ARN of the new role that was created for our function. The Role ARN is the ID of the role that we will use to give that role access to S3.\u003c/p\u003e\n\u003cp\u003eLater, when we deploy a production function, we will change the execution role of the production function to match dev role which will give the production function the same access that the dev function has.\u003c/p\u003e\n\u003cp\u003eBut first, we need that Role ARN.\u003c/p\u003e\n\u003cp\u003eLog in to your AWS console and go to the Lambda service.\u003c/p\u003e\n\u003cp\u003eYou should see our function on the list. Go ahead and click it.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.filestackcontent.com/HjebSOAcRXqJCPhLBkmo\" alt=\"skitch.png\"\u003e\u003c/p\u003e\n\u003cp\u003eScroll down to the section that says \"Execution Role\" and you should see the role that is currently selected. Don't change it — we just needed to see the name of the role.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.filestackcontent.com/C5ZeY2CVTzGROwYIuVnQ\" alt=\"skitch.png\"\u003e\u003c/p\u003e\n\u003cp\u003eNow, get the Role ARN by going to the IAM service in the AWS console, click on \"Roles\" in the sidebar, and select the role for the function. You should see the \"Role ARN\" at the top of the role page.\u003c/p\u003e\n\u003cp\u003eOr, if you have the AWS CLI installed, you can get the Role ARN by running this command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eaws iam get-role --role-name name-of-role\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe Role ARN should look something like this:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003earn:aws:iam::525814828111:role/business-cardistry-dev-us-east-1-lambdaRole\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eNow, go to the S3 service.\u003c/p\u003e\n\u003cp\u003eClick \"Create Bucket.\"\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.filestackcontent.com/nJLo9YqTFmVxKwzAlIrA\" alt=\"skitch.png\"\u003e\u003c/p\u003e\n\u003cp\u003eGive the bucket a name but leave everything else at its default value by clicking \"Next,\" \"Next,\" \"Next,\" \"Create Bucket.\"\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.filestackcontent.com/3PGjDW4tTFedF6jGQQQM\" alt=\"skitch.png\"\u003e\u003c/p\u003e\n\u003cp\u003eThen, click on your newly created bucket.\u003c/p\u003e\n\u003cp\u003eSelect the Permissions tab, then Bucket Policy.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.filestackcontent.com/tMCgzh96Tv2Y6TsODsZv\" alt=\"skitch.png\"\u003e\u003c/p\u003e\n\u003cp\u003ePaste this into the editor. Be sure to replace \u003cem\u003erole-goes-here\u003c/em\u003e with the Role ARN.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"AllowPutForAllS3TestfilesLambda\",\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"AWS\": \"role-goes-here\"\n            },\n            \"Action\": \"s3:*\",\n            \"Resource\": \"arn:aws:s3:::business-cardistry/*\"\n        }\n    ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlright, this policy allows our custom role to perform all S3 actions on our new S3 bucket. S3 should be good to go!\u003c/p\u003e\n\u003ch3 id=\"code-our-function\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#code-our-function\"\u003e\u003ca href=\"#code-our-function\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eCode Our Function\u003c/h3\u003e\n\u003cp\u003eOkay, now we can get to coding. Let's make our \u003ccode\u003epdf\u003c/code\u003e function. It needs to receive some HTML, process it into a PDF file buffer, then then upload that buffer to S3.\u003c/p\u003e\n\u003cp\u003eLet's initialize npm and add some dependencies.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ npm init -y\n$ npm install --save html-pdf aws-sdk shortid\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ehtml-pdf\u003c/code\u003e library we are using requires the program \u003ccode\u003ephantomjs\u003c/code\u003e to be available as an executable binary. Normally, if we were running this script on a server, we would just install \u003ccode\u003ephantomjs\u003c/code\u003e on the server. Because this is serverless, we need to make sure that the runtime context has access to the \u003ccode\u003ephantomjs\u003c/code\u003e executable binary.\u003c/p\u003e\n\u003cp\u003eThe way I handled this was to \u003ca href=\"http://phantomjs.org/download.html\"\u003edownload the binary\u003c/a\u003e and put it into a \u003ccode\u003ebin\u003c/code\u003e folder in the project root.\u003c/p\u003e\n\u003cp\u003eThen, I made sure to add this to the serverless.yml file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage:\n  include:\n    - bin/phantomjs\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, when the function is deployed, it grabs that binary and uploads it while preserving its permissions and making it available in the runtime environment of the function.\u003c/p\u003e\n\u003cp\u003eOkay. Let's get to the code. Here is what my \u003ccode\u003epdf\u003c/code\u003e function looks like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e'use strict';\n\nconst pdf = require('html-pdf');\nconst path = require('path');\nconst AWS = require('aws-sdk');\nconst shortid = require('shortid');\n\nmodule.exports.pdf = (event, context, callback) =\u003e {\n  const html = event.body;\n  pdf.create(html, {\n    height: '200px',\n    width: '350px',\n    phantomPath: path.resolve(process.env.LAMBDA_TASK_ROOT, 'bin/phantomjs'),\n  }).toBuffer((err, buffer) =\u003e {\n    if (err) return console.log(err);\n\n    const fileKey = `cards/${shortid.generate()}.pdf`;\n    const bucket = 'business-cardistry';\n\n    const s3 = new AWS.S3();\n    s3.putObject({\n      Bucket: bucket,\n      Key: fileKey,\n      Body: buffer,\n      ACL: 'public-read'\n    },function (resp) {\n      const fileUrl = s3.getSignedUrl('getObject', {\n        Bucket: bucket,\n        Key: fileKey,\n        Expires: 60,\n      });\n\n      callback(null, {\n        statusCode: 200,\n        headers: {\n          'Content-Type' : 'application/json',\n          'Access-Control-Allow-Origin' : '*',\n        },\n        body: JSON.stringify({ fileUrl }),\n      });\n    });\n  });\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eI'm not going to go into the code too deeply, but it takes the body of the request and uses it to generate a PDF buffer. It then uploads the buffer to S3 and returns a signed URL for the uploaded object.\u003c/p\u003e\n\u003cp\u003eYou see the line that says \u003ccode\u003epath.resolve(process.env.LAMBDA_TASK_ROOT, 'bin/phantomjs')\u003c/code\u003e? This is how we reference that phantomjs executable binary.\u003c/p\u003e\n\u003cp\u003eYou'll notice that we don't need to specify any AWS credentials. It automatically gets the credentials from the execution role.\u003c/p\u003e\n\u003ch3 id=\"testing-and-final-deployment\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#testing-and-final-deployment\"\u003e\u003ca href=\"#testing-and-final-deployment\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eTesting and Final Deployment\u003c/h3\u003e\n\u003cp\u003eSince this endpoint simply receives HTML and returns a filepath, we should still be able to test it with a curl command. First, let's deploy to dev again.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eserverless deploy -s dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe above deploy command will deploy the whole project. To deploy only one function, you can use the command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eserverless deploy function -f pdf -s dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you run into any errors, you can check the logs for the \u003ccode\u003epdf\u003c/code\u003e function with this command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elogs -f pdf -s dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we can test it by sending another curl request with a string of HTML\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ curl -d '\u0026#x3C;h1\u003eHello PDF!\u0026#x3C;/h1\u003e' -X POST https://o20pczjzbl.execute-api.us-east-1.amazonaws.com/dev/pdf\n{\"fileUrl\":\"https://business-cardis...j2hJHSBQ%3D%3D\"}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt works! When I paste in the fileUrl link into a browser, it downloads a PDF that looks like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.filestackcontent.com/VKbRNpBATGGvLVGmV9W7\" alt=\"SJ5Orpb7M-1.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eWhich is exactly what we expect.\u003c/p\u003e\n\u003cp\u003eSo now, let's deploy in production!\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ serverless deploy -s production\nServerless: Packaging service...\nServerless: Excluding development dependencies...\nServerless: Creating Stack...\nServerless: Checking Stack create progress...\n.....\nServerless: Stack create finished...\nServerless: Uploading CloudFormation file to S3...\nServerless: Uploading artifacts...\nServerless: Uploading service .zip file to S3 (35.56 MB)...\nServerless: Validating template...\nServerless: Updating Stack...\nServerless: Checking Stack update progress...\n..............................\nServerless: Stack update finished...\nService Information\nservice: business-cardistry\nstage: production\nregion: us-east-1\nstack: business-cardistry-production\napi keys:\n  None\nendpoints:\n  POST - https://8103v1xvqk.execute-api.us-east-1.amazonaws.com/production/pdf\nfunctions:\n  pdf: business-cardistry-production-pdf\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, this created a whole new function in Lambda, so remember all of that talk about execution roles? We need to change the execution role of the production function to match the role of the dev function. That way the production function will have access to S3 as well..\u003c/p\u003e\n\u003cp\u003eSo go back to the Lambda page in AWS, click on the new production function that was just created, and change the Execution Role to the dev role:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://cdn.filestackcontent.com/xji2HYMZQySyeb74aIL7\" alt=\"skitch.png\"\u003e\u003c/p\u003e\n\u003cp\u003eOnce that's done, we can double check the production endpoint.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ curl -d '\u0026#x3C;h1\u003eHello PDF!\u0026#x3C;/h1\u003e' -X POST https://8103v1xvqk.execute-api.us-east-1.amazonaws.com/production/pdf\n{\"fileUrl\":\"https://business-cardis...j2hJHSBQ%3D%3D\"}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAaaaaand it works! Now after modifying the request URL in my React code, my app is complete!\u003c/p\u003e\n\u003cp\u003eBe sure to check out \u003ca href=\"http://cardistry.nmajor.com/\"\u003ecardistry.nmajor.com\u003c/a\u003e to see it in action.\u003c/p\u003e\n\u003cp\u003eI know this was just a simple example with one endpoint, but this same process could be used to build dozens of endpoints for almost any app. I hope this gives you a good idea of what's possible with serverless, and how easy and powerful it can be!\u003c/p\u003e\n\u003ch2 id=\"limitations-and-drawbacks-of-serverless\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#limitations-and-drawbacks-of-serverless\"\u003e\u003ca href=\"#limitations-and-drawbacks-of-serverless\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eLimitations and Drawbacks of Serverless\u003c/h2\u003e\n\u003cp\u003eAs awesome as serverless is, there are some limitations and drawbacks:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLatency\u003c/strong\u003e\u003cbr\u003e\nAlthough AWS Lambda is designed to execute functions in milliseconds, you do have some added latency when using serverless. However, we are talking about a few hundred added milliseconds. For most web applications, it's not going to be an issue, but if latency is really important for your project, it's something you are going to want to consider.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eVendor Lock-in\u003c/strong\u003e\nBecause serverless relies so heavily on the infrastructure and the supporting services, but you may need to re-write large parts of your application to move it to a different provider.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBlack Box\u003c/strong\u003e\u003cbr\u003e\nMany of the parts of your application are out of your control, so when things go wrong or if you hit an edge use-case with your app, you have little control over your ability to resolve it yourself.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNew Tech\u003c/strong\u003e\u003cbr\u003e\nServerless is still in its infancy, so, as with any new technology, great care should be used when deciding whether or not to jump on the bandwagon early.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#conclusion\"\u003e\u003ca href=\"#conclusion\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eI believe serverless is the next big thing in web development. So much in web development is the same. Every framework solves many of the same problems in the same way. Serverless is solving those problems at the infrastructural level, leaving you free to work on the important and different parts of your App.\u003c/p\u003e\n\u003cp\u003eCombine that with cost and scalability benefits, and the fact that there are so many amazing front-end frameworks like React, and the days of traditional back-end frameworks are numbered.\u003c/p\u003e\n\u003ch2 id=\"other-resources\"\u003e\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#other-resources\"\u003e\u003ca href=\"#other-resources\" style=\"margin-right: 10px\"\u003e#\u003c/a\u003e\u003c/a\u003eOther Resources:\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://serverless-stack.com/\"\u003eserverless-stack.com\u003c/a\u003e — A comprehensive tutorial on building and deploying full-stack apps using Serverless and React on AWS.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://serverless.com/\"\u003eserverless.com\u003c/a\u003e — Great documentation, community, and other resources.\u003c/li\u003e\n\u003c/ul\u003e"])</script><script>self.__next_f.push([1,"c:[\"$\",\"div\",null,{\"className\":\"sm:px-8 post mt-16 lg:mt-32\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto w-full max-w-7xl lg:px-8\",\"children\":[\"$\",\"div\",null,{\"className\":\"relative px-4 sm:px-8 lg:px-12\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-2xl lg:max-w-5xl\",\"children\":[\"$\",\"div\",null,{\"className\":\"xl:relative\",\"children\":[\"$\",\"div\",null,{\"className\":\"mx-auto max-w-2xl\",\"children\":[\"$\",\"article\",null,{\"children\":[[\"$\",\"header\",null,{\"className\":\"flex flex-col\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-4xl font-bold font-bold tracking-tight sm:text-5xl\",\"children\":\"Serverless Back-End for React - Your Introduction to Serverless Architecture\"}],[\"$\",\"div\",null,{\"className\":\"flex gap-3 pt-1\",\"children\":[[\"$\",\"time\",null,{\"dateTime\":\"2018-01-29\",\"className\":\"text-muted-foreground order-first flex items-center pr-2 text-base\",\"children\":[[\"$\",\"span\",null,{\"className\":\"h-4 w-0.5 rounded-full bg-zinc-200 dark:bg-zinc-500\"}],[\"$\",\"span\",null,{\"className\":\"ml-3\",\"children\":\"January 29, 2018\"}]]}],[\"$\",\"span\",null,{\"className\":\"text-muted-foreground\",\"children\":\"-\"}],[[\"$\",\"span\",\"serverless\",{\"className\":\"text-muted-foreground/80\",\"children\":\"serverless\"}],[\"$\",\"span\",\"react\",{\"className\":\"text-muted-foreground/80\",\"children\":\"react\"}],[\"$\",\"span\",\"aws\",{\"className\":\"text-muted-foreground/80\",\"children\":\"aws\"}]]]}],[\"$\",\"div\",null,{\"className\":\"text-accent-foreground pt-3 text-sm italic\",\"children\":[\"~\",\"16 min read\"]}]]}],[\"$\",\"div\",null,{\"className\":\"mt-8 prose dark:prose-invert\",\"data-mdx-content\":true,\"children\":[\"$\",\"div\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$d\"}}]}]]}]}]}]}]}]}]}]\n"])</script><script>self.__next_f.push([1,"4:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Serverless Back-End for React - Your Introduction to Serverless Architecture - Spencer Sharp\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"I’m Spencer, a software designer and entrepreneur based in New York City. I’m the founder and CEO of Planetaria, where we develop technologies that empower regular people to explore space on their own terms.\"}],[\"$\",\"link\",\"4\",{\"rel\":\"alternate\",\"type\":\"application/rss+xml\",\"href\":\"undefined/feed.xml\"}]]\n"])</script><script>self.__next_f.push([1,"b:null\n"])</script><script>self.__next_f.push([1,""])</script></body></html>